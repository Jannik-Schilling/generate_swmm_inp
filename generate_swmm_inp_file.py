# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2021 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2024-08-07'
__copyright__ = '(C) 2021 by Jannik Schilling'


# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import pandas as pd
import numpy as np
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterDefinition,
    QgsProcessingParameterFile,
    QgsProcessingParameterFileDestination,
    QgsProcessingParameterVectorLayer
)
from .g_s_export_helpers import (
    check_columns,
    check_deprecated,
    data_preparation,
    get_coords_from_geometry,
    use_z_if_available
)
from .g_s_defaults import (
    annotation_field_name,
    def_qgis_fields_dict,
    def_sections_geoms_list,
    def_tables_dict,
    curve_cols_dict,
    def_sections_dict
)
from .g_s_read_write_data import (
    read_data_direct
)


class GenerateSwmmInpFile(QgsProcessingAlgorithm):
    """
    generates a swmm input file from geodata and tables
    """
    QGIS_OUT_INP_FILE = 'QGIS_OUT_INP_FILE'
    FILE_RAINGAGES = 'FILE_RAINGAGES'
    FILE_CONDUITS = 'FILE_CONDUITS'
    FILE_JUNCTIONS = 'FILE_JUNCTIONS'
    FILE_DIVIDERS = 'FILE_DIVIDERS'
    FILE_ORIFICES = 'FILE_ORIFICES'
    FILE_OUTFALLS = 'FILE_OUTFALLS'
    FILE_OUTLETS = 'FILE_OUTLETS'
    FILE_STORAGES = 'FILE_STORAGES'
    FILE_PUMPS = 'FILE_PUMPS'
    FILE_SUBCATCHMENTS = 'FILE_SUBCATCHMENTS'
    FILE_WEIRS = 'FILE_WEIRS'
    FILE_CURVES = 'FILE_CURVES'
    FILE_PATTERNS = 'FILE_PATTERNS'
    FILE_OPTIONS = 'FILE_OPTIONS'
    FILE_TIMESERIES = 'FILE_TIMESERIES'
    FILE_INFLOWS = 'FILE_INFLOWS'
    FILE_QUALITY = 'FILE_QUALITY'
    FILE_TRANSECTS = 'FILE_TRANSECTS'
    FILE_STREETS = 'FILE_STREETS'
    USE_Z_VALS = 'USE_Z_VALS'

    def initAlgorithm(self, config):
        """
        inputs and output of the algorithm
        """
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.QGIS_OUT_INP_FILE,
                self.tr('Where should the inp file be saved?'),
                'INP files (*.inp)',
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_RAINGAGES,
                self.tr('Rain gages Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_JUNCTIONS,
                self.tr('Junctions Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_CONDUITS,
                self.tr('Conduits Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_SUBCATCHMENTS,
                self.tr('Subcatchments Layer'),
                types=[QgsProcessing.SourceType.TypeVectorAnyGeometry],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_STORAGES,
                self.tr('Storages Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_OUTFALLS,
                self.tr('Outfalls Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_DIVIDERS,
                self.tr('Dividers Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_PUMPS,
                self.tr('Pumps Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_WEIRS,
                self.tr('Weirs Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_ORIFICES,
                self.tr('Orifices Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_OUTLETS,
                self.tr('Outlets Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional=True
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_OPTIONS,
                self.tr('Options table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_CURVES,
                self.tr('Curves table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_PATTERNS,
                self.tr('Patterns table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_TIMESERIES,
                self.tr('Timeseries table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_INFLOWS,
                self.tr('Inflows table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_QUALITY,
                self.tr('Quality table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_TRANSECTS,
                self.tr('Transects table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                self.FILE_STREETS,
                self.tr('Streets and Inlets table file'),
                QgsProcessingParameterFile.File,
                optional=True,
                fileFilter='Tables (*.xlsx *.xls *.odf)'
            )
        )

        use_z_vals_param = QgsProcessingParameterBoolean(
            self.USE_Z_VALS,
            self.tr(
                'Use z-coordinates for conduits and nodes instead'
                +' of \"Elevation\"/\"InOffset\"/\"OutOffset\" in '
                +'the attribute tables'    
            ),
            defaultValue=False,
            optional=True
        )
        use_z_vals_param.setFlags(use_z_vals_param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(use_z_vals_param)

    def processAlgorithm(self, parameters, context, feedback):
        """
        main process algorithm of this tool
        """
        # input file name and path"
        inp_file_path = self.parameterAsString(parameters, self.QGIS_OUT_INP_FILE, context)
        inp_file_name = os.path.basename(inp_file_path)
        project_dir = os.path.dirname(inp_file_path)
        # advanced parameter for z_values
        use_z_bool = self.parameterAsBoolean(parameters, self.USE_Z_VALS, context)  # del
        
        export_params = {
            'use_z_bool': self.parameterAsBoolean(parameters, self.USE_Z_VALS, context),
            'main_infiltration_method': None,
        }

        # initializing the input dictionary
        """
        inp_dict = {
            SECTION: {
                'data': pd.df,
                'annotations': {
                    'object_name1': 'annotation_string'
                    'object_name2': 'annotation_string'
                }
            }
        }
        """
        inp_dict = dict()
        inp_dict['TITLE'] = {'data': pd.DataFrame(['test'])}
        inp_dict['XSECTIONS'] = {
            'data': pd.DataFrame(),
            'annotations': {}
        } 
        inp_dict['COORDINATES'] = {'data': pd.DataFrame()}
        inp_dict['VERTICES'] = {'data': dict()}

        # putting together all dita in a dict
        export_data = {
            # layers
            'RAINGAGE': {'file': self.parameterAsVectorLayer(parameters, self.FILE_RAINGAGES, context)},
            'OUTFALLS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_OUTFALLS, context)},
            'STORAGE': {'file': self.parameterAsVectorLayer(parameters, self.FILE_STORAGES, context)},
            'SUBCATCHMENTS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_SUBCATCHMENTS, context)},
            'CONDUITS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_CONDUITS, context)},
            'JUNCTIONS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_JUNCTIONS, context)},
            'PUMPS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_PUMPS, context)},
            'WEIRS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_WEIRS, context)},
            'ORIFICES': {'file': self.parameterAsVectorLayer(parameters, self.FILE_ORIFICES, context)},
            'OUTLETS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_OUTLETS, context)},
            'DIVIDERS': {'file': self.parameterAsVectorLayer(parameters, self.FILE_DIVIDERS, context)},
            # tables
            'OPTIONS': {'file': self.parameterAsString(parameters, self.FILE_OPTIONS, context)},
            'INFLOWS': {'file': self.parameterAsString(parameters, self.FILE_INFLOWS, context)},
            'PATTERNS': {'file': self.parameterAsString(parameters, self.FILE_PATTERNS, context)},
            'CURVES': {'file': self.parameterAsString(parameters, self.FILE_CURVES, context)},
            'QUALITY': {'file': self.parameterAsString(parameters, self.FILE_QUALITY, context)},
            'TIMESERIES': {'file': self.parameterAsString(parameters, self.FILE_TIMESERIES, context)},
            'TRANSECTS': {'file': self.parameterAsString(parameters, self.FILE_TRANSECTS, context)},
            'STREETS': {'file': self.parameterAsString(parameters, self.FILE_STREETS, context)},
        }
        export_data = {k: v for k, v in export_data.items() if v['file'] is not None}
        export_data = {k: v for k, v in export_data.items() if v['file'] != ''}
        
        # adding data type information
        for k in export_data.keys():
            if k in def_sections_geoms_list:
                export_data[k]['d_type'] = 'layer'
            elif k in def_tables_dict.keys():
                export_data[k]['d_type'] = 'table'
            else:
                #unknown data type
                raise QgsProcessingException(
                    'Unknown file type for file ' 
                    + k
                )
        feedback.setProgressText(self.tr('done \n'))


        # check crs for layer
        feedback.setProgressText('Checking CRS of layers...')
        raw_layers_crs_list = [
            v['file'].crs().authid() for v in export_data.values() if v['d_type'] == 'layer'
        ]
        unique_crs = np.unique(raw_layers_crs_list)
        if len(unique_crs) > 1:
            feedback.pushWarning(
                'Warning: different CRS in the selected layers.'
                + 'This may lead to unexpected locations in SWMM'
            )
        feedback.setProgressText(self.tr('done \n'))


        # store pandas dataframes for each layer     
        feedback.setProgressText('Reading layers and tables...')   
        read_data_direct(export_data, feedback = feedback)
        feedback.setProgressText(self.tr('done \n'))
        print(export_data)


        feedback.setProgressText(self.tr('preparing data for input file:'))
        
        # function for annotations / descriptions
        def get_annotations_from_raw_df(df_raw):
            if annotation_field_name in df_raw.columns:
                annot_dict = {k: v for k, v in zip(df_raw['Name'], df_raw[annotation_field_name])}  
                annot_dict = {k: v for k, v in annot_dict.items() if pd.notna(v)}
                annot_dict = {k: v for k, v in annot_dict.items() if len(v) > 0}
            else:
                annot_dict = {}
            return annot_dict

            
        # main handler
        def data_export_handler(
            data_name,
            export_data,
            inp_dict,
            export_params
        ):
            # check columns
            data_entry = export_data[data_name]
            data_type = data_entry['d_type']
            f_name = data_entry['file']
            if data_type == 'table':
                for sheet_name in data_entry['data'].keys():
                    cols_to_check = list(def_tables_dict[data_name]['tables'][sheet_name].keys())
                    check_columns(
                        f_name,
                        cols_to_check,
                        data_entry['data'][sheet_name].keys()
                    )
            else:
                cols_to_check = list(def_qgis_fields_dict[section].keys())
                check_columns(
                    f_name,
                    cols_to_check,
                    data_entry['data'].keys()
                )

            # data preparation
            processed_data_dict = data_preparation(
                data_name,
                data_entry,
                export_params
            )
            
            # geometry
            if data_type == 'layer':
                sections_coords = get_coords_from_geometry(raw_df)
                use_z_if_available()
                adjust_geometry()
            
            # annotations
            if data_name != 'OPTIONS':
                #annotations_df = get_annotations_from_raw_df(
                #    raw_data_dict['conduits_raw'].copy()
                #)
                annotations_df = None
                if annotations_df is not None:
                    # das ggf. fÃ¼r jede subgruppe
                    inp_dict[data_name]['annotations'] = annotations_df

                
            # write to inp dict
            inp_dict.update(processed_data_dict)

                


        data_export_handler(
            'OPTIONS',
            export_data,
            inp_dict,
            export_params
        )

        print(export_params)




        # subcatchments
        if 'subcatchments_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[SUBCATCHMENTS] section'))
            from .g_s_subcatchments import get_subcatchments_from_layer
            # check if all columns exist
            all_sub_cols = list(def_qgis_fields_dict['SUBCATCHMENTS'].keys())
            subc_layer_name = 'Subcatchments Layer'
            check_columns(
                subc_layer_name,
                all_sub_cols,
                raw_data_dict['subcatchments_raw'].keys()
            )
            subcatchments_df, subareas_df, infiltration_df = get_subcatchments_from_layer(
                raw_data_dict['subcatchments_raw'].copy(),
                export_params['main_infiltration_method']
            )
            inp_dict['POLYGONS'] = {'data':
                get_coords_from_geometry(raw_data_dict['subcatchments_raw'])
            }
            subcatchments_annot = get_annotations_from_raw_df(
                raw_data_dict['subcatchments_raw'].copy()
            )
            inp_dict['SUBCATCHMENTS'] = {
                'data': subcatchments_df,
                'annotations': subcatchments_annot
            }
            inp_dict['SUBAREAS'] = {'data': subareas_df}
            inp_dict['INFILTRATION'] = {'data': infiltration_df}

        # conduits
        if 'conduits_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[CONDUITS] section'))
            raw_data_dict['conduits_raw'] = check_deprecated(
                swmm_data_file='Conduits Layer',
                swmm_section='CONDUITS',
                df=raw_data_dict['conduits_raw'],
                cols_deprecated={'Shape': 'XsectShape'},
                feedback=feedback
            )
            from .g_s_links import get_conduits_from_shapefile, del_first_last_vt
            conduits_df, xsections_df, losses_df = get_conduits_from_shapefile(raw_data_dict['conduits_raw'].copy())
            conduits_verts = get_coords_from_geometry(raw_data_dict['conduits_raw'].copy())
            conduits_df, conduits_verts = use_z_if_available(
                conduits_df,
                conduits_verts,
                use_z_bool,
                feedback,
                'lines',
                layer_name='conduits_layer'
            )
            conduits_verts = {k: del_first_last_vt(v) for k, v in conduits_verts.items() if len(v) > 2}  # first and last vertices are in nodes coordinates anyway
            inp_dict['VERTICES']['data'].update(conduits_verts)
            conduits_annot = get_annotations_from_raw_df(
                raw_data_dict['conduits_raw'].copy()
            )
            inp_dict['CONDUITS'] = {
                'data': conduits_df,
                'annotations': conduits_annot
            }
            inp_dict['XSECTIONS'] = {'data': xsections_df}
            inp_dict['LOSSES'] = {'data': losses_df}

        # pumps
        if 'pumps_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[PUMPS] section'))
            from .g_s_links import get_pumps_from_shapefile, del_first_last_vt
            pumps_df = get_pumps_from_shapefile(raw_data_dict['pumps_raw'].copy())
            pumps_annot = get_annotations_from_raw_df(
                raw_data_dict['pumps_raw'].copy()
            )
            pumps_verts = get_coords_from_geometry(raw_data_dict['pumps_raw'].copy())
            pumps_df, pumps_verts = use_z_if_available(
                pumps_df,
                pumps_verts,
                False,
                feedback,
                geom_type = 'lines'
            )
            pumps_verts = {k: del_first_last_vt(v) for k, v in pumps_verts.items() if len(v) > 2}
            pumps_inp_cols = def_sections_dict['PUMPS']
            inp_dict['VERTICES']['data'].update(pumps_verts)
            inp_dict['PUMPS'] = {
                'data': pumps_df[pumps_inp_cols],
                'annotations': pumps_annot
            }

        # weirs
        if 'weirs_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[WEIRS] section'))
            from .g_s_links import get_weirs_from_shapefile, del_first_last_vt
            weirs_df, xsections_df = get_weirs_from_shapefile(raw_data_dict['weirs_raw'])
            weirs_annot = get_annotations_from_raw_df(
                raw_data_dict['weirs_raw'].copy()
            )
            weirs_verts = get_coords_from_geometry(raw_data_dict['weirs_raw'].copy())
            weirs_df, weirs_verts = use_z_if_available(
                weirs_df,
                weirs_verts,
                False,
                feedback,
                geom_type = 'lines'
            )
            weirs_verts = {k: del_first_last_vt(v) for k, v in weirs_verts.items() if len(v) > 2}  # first and last vertices are in nodes coordinates anyway
            inp_dict['VERTICES']['data'].update(weirs_verts)
            inp_dict['XSECTIONS']['data'] = pd.concat(
                [inp_dict['XSECTIONS']['data'], xsections_df],
                ignore_index = True
            )
            inp_dict['WEIRS'] = {
                'data': weirs_df,
                'annotations': weirs_annot
            }

        # outlets
        if 'outlets_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[OUTLETS] section'))
            from .g_s_links import get_outlets_from_shapefile, del_first_last_vt
            outlets_annot = get_annotations_from_raw_df(
                raw_data_dict['outlets_raw'].copy()
            )            
            outlets_df = get_outlets_from_shapefile(raw_data_dict['outlets_raw'])
            inp_dict['OUTLETS'] = {
                'data': outlets_df,
                'annotations': outlets_annot
            }
            outlets_verts = get_coords_from_geometry(raw_data_dict['outlets_raw'].copy())
            outlets_df, outlets_verts = use_z_if_available(
                outlets_df,
                outlets_verts,
                False,
                feedback,
                geom_type = 'lines'
            )
            outlets_verts = {k: del_first_last_vt(v) for k, v in outlets_verts.items() if len(v) > 2}
            inp_dict['VERTICES']['data'].update(outlets_verts)

        # optional: transects for conduits or weirs
        if 'conduits_raw' in export_data.keys() or 'weirs_raw' in export_data.keys():
            if 'transects' in raw_data_dict.keys():
                feedback.setProgressText(self.tr('[TRANSECTS] section'))
                from .g_s_links import get_transects_from_table
                transects_string_list = get_transects_from_table(raw_data_dict['transects'].copy())
                inp_dict['TRANSECTS'] = {'data': transects_string_list}

        # orifices
        if 'orifices_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[ORIFICES] section'))
            raw_data_dict['orifices_raw'] = check_deprecated(
                swmm_data_file='Orifices Layer',
                swmm_section='ORIFICES',
                df=raw_data_dict['orifices_raw'],
                cols_deprecated={'Shape': 'XsectShape'},
                feedback=feedback
            )
            from .g_s_links import get_orifices_from_shapefile, del_first_last_vt
            orifices_df, xsections_df = get_orifices_from_shapefile(raw_data_dict['orifices_raw'])
            orifices_annot = get_annotations_from_raw_df(
                raw_data_dict['orifices_raw'].copy()
            )
            orifices_verts = get_coords_from_geometry(raw_data_dict['orifices_raw'].copy())
            orifices_df, orifices_verts = use_z_if_available(
                orifices_df,
                orifices_verts,
                False,
                feedback,
                geom_type = 'lines'
            )
            orifices_verts = {k: del_first_last_vt(v) for k, v in orifices_verts.items() if len(v) > 2}  # first and last vertices are in nodes coordinates anyway
            inp_dict['VERTICES']['data'].update(orifices_verts)
            inp_dict['XSECTIONS']['data'] = pd.concat(
                [inp_dict['XSECTIONS']['data'], xsections_df],
                ignore_index = True
            )
            inp_dict['XSECTIONS']['data'] = inp_dict['XSECTIONS']['data'].reset_index(drop=True)
            inp_dict['ORIFICES'] = {
                'data': orifices_df,
                'annotations': orifices_annot
            }

        feedback.setProgress(40)

        # nodes (junctions, outfalls, orifices)
        all_nodes = list()
        if 'junctions_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[JUNCTIONS] section'))
            # check columns
            junctions_cols = list(def_qgis_fields_dict['JUNCTIONS'].keys())
            junctions_layer_name = 'Junctions Layer'
            check_columns(
                junctions_layer_name,
                junctions_cols,
                raw_data_dict['junctions_raw'].keys()
            )
            junctions_df = raw_data_dict['junctions_raw'].copy()
            junctions_df['Name'] = [str(x) for x in junctions_df['Name']]
            junctions_df['MaxDepth'] = junctions_df['MaxDepth'].fillna(0)
            junctions_df['InitDepth'] = junctions_df['InitDepth'].fillna(0)
            junctions_df['SurDepth'] = junctions_df['SurDepth'].fillna(0)
            junctions_df['Aponded'] = junctions_df['Aponded'].fillna(0)
            junctions_annot = get_annotations_from_raw_df(
                raw_data_dict['junctions_raw'].copy()
            )
            junctions_coords = get_coords_from_geometry(junctions_df)
            junctions_inp_cols = def_sections_dict['JUNCTIONS']
            junctions_df, junctions_coords = use_z_if_available(
                junctions_df,
                junctions_coords,
                use_z_bool,
                feedback,
                geom_type='Points',
                layer_name='junctions_layer'
            )
            inp_dict['JUNCTIONS'] = {
                'data': junctions_df[junctions_inp_cols],
                'annotations': junctions_annot
            }
            inp_dict['COORDINATES']['data'] = pd.concat(
                [inp_dict['COORDINATES']['data'], junctions_coords],
                ignore_index = True
            )
            all_nodes = all_nodes+junctions_df['Name'].tolist()
        if 'outfalls_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[OUTFALLS] section'))
            outfalls_cols = list(def_qgis_fields_dict['OUTFALLS'].keys())
            outfalls_layer_name = 'Outfalls Layer'
            check_columns(
                outfalls_layer_name,
                outfalls_cols,
                raw_data_dict['outfalls_raw'].keys()
            )
            from .g_s_nodes import get_outfalls_from_shapefile
            outfalls_df = get_outfalls_from_shapefile(raw_data_dict['outfalls_raw'].copy())
            outfalls_coords = get_coords_from_geometry(outfalls_df)
            outfalls_annot = get_annotations_from_raw_df(
                raw_data_dict['outfalls_raw'].copy()
            )
            outfalls_df, outfalls_coords = use_z_if_available(
                outfalls_df,
                outfalls_coords,
                use_z_bool,
                feedback,
                geom_type='Points',
                layer_name='outfalls_layer'
            )
            inp_dict['OUTFALLS'] = {
                'data': outfalls_df,
                'annotations': outfalls_annot
            }
            inp_dict['COORDINATES']['data'] = pd.concat(
                [inp_dict['COORDINATES']['data'], outfalls_coords],
                ignore_index = True
            )
            all_nodes = all_nodes+outfalls_df['Name'].tolist()

        if 'storages_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[STORAGES] section'))
            # check columns is performed within get_storages_from_geodata for different storage types
            from .g_s_nodes import get_storages_from_geodata
            storage_df = get_storages_from_geodata(
                raw_data_dict['storages_raw'].copy()
            )
            storage_annot = get_annotations_from_raw_df(
                raw_data_dict['storages_raw'].copy()
            )
            storage_coords = get_coords_from_geometry(raw_data_dict['storages_raw'].copy())
            storage_df, storage_coords = use_z_if_available(
                storage_df,
                storage_coords,
                use_z_bool,
                feedback,
                geom_type='Points',
                layer_name='storages_layer'
            )
            storage_inp_cols = [
                'Name', 'Elevation', 'MaxDepth','InitDepth','Type',
                'Shape1','Shape2','Shape3','SurDepth','Fevap','Psi',
                'Ksat','IMD'
            ]
            storage_df = storage_df[storage_inp_cols]
            inp_dict['COORDINATES']['data'] = pd.concat(
                [inp_dict['COORDINATES']['data'], storage_coords],
                ignore_index = True
            )
            inp_dict['STORAGE'] = {
                'data': storage_df,
                'annotations': storage_annot
            }
            all_nodes = all_nodes+storage_df['Name'].tolist()
        if 'dividers_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[DIVIDERS] section'))
            dividers_df = raw_data_dict['dividers_raw'].copy()
            dividers_coords = get_coords_from_geometry(dividers_df)
            # check columns
            dividers_cols = list(def_qgis_fields_dict['DIVIDERS'].keys())
            dividers_layer_name = 'Dividers Layer'
            check_columns(dividers_layer_name,
                          dividers_cols,
                          dividers_df.keys())
            dividers_df['Name'] = [str(x) for x in dividers_df['Name']]
            dividers_df['CutoffFlow'] = dividers_df['CutoffFlow'].fillna('')
            dividers_df['Curve'] = dividers_df['Curve'].fillna('')
            dividers_df['WeirMinFlo'] = dividers_df['WeirMinFlo'].fillna('')
            dividers_df['WeirMaxDep'] = dividers_df['WeirMaxDep'].fillna('')
            dividers_df['WeirCoeff'] = dividers_df['WeirCoeff'].fillna('')
            dividers_annot = get_annotations_from_raw_df(
                raw_data_dict['dividers_raw'].copy()
            )
            dividers_df, dividers_coords = use_z_if_available(
                dividers_df,
                dividers_coords,
                use_z_bool,
                feedback,
                geom_type='Points',
                layer_name='dividers_layer'
            )
            inp_dict['DIVIDERS'] = {
                'data': dividers_df,
                'annotations': dividers_annot
            }
            inp_dict['COORDINATES']['data'] = pd.concat(
                [inp_dict['COORDINATES']['data'], dividers_coords],
                ignore_index = True
            )
            all_nodes = all_nodes+dividers_df['Name'].tolist()
        feedback.setProgress(50)

        # inflows
        if len(all_nodes) > 0:
            if 'inflows' in export_data.keys():
                feedback.setProgressText(self.tr('[INFLOWS] section'))
                from .g_s_nodes import get_inflows_from_table
                dwf_dict, inflow_dict, hydrogr_df, rdii_df = get_inflows_from_table(
                    raw_data_dict['inflows'],
                    all_nodes,
                    feedback
                )
                if len(inflow_dict) > 0:
                    inp_dict['INFLOWS'] = {'data': inflow_dict}
                if len(dwf_dict) > 0:
                    inp_dict['DWF'] = {'data': dwf_dict}
                if len(hydrogr_df) > 0:
                    inp_dict['HYDROGRAPHS'] = {'data': hydrogr_df}
                if len(rdii_df) > 0:
                    if len (hydrogr_df) == 0:
                        feedback.pushWarning(
                            'Warning: No hydrographs were provided for RDII'
                            + '. Please check if the correct file was selected '
                            + 'and the \"Hydrographs\" table is set up correctly. '
                            + 'The RDII section will not be written into the input file '
                            + 'to avoid errors in SWMM.'
                        )
                    else:
                        needed_U_H = list(rdii_df['UnitHydrograph'])
                        misshing_U_H = [h for h in needed_U_H if h not in list(hydrogr_df['Name'])]
                        if len (misshing_U_H) > 0:
                            feedback.pushWarning(
                                'Warning: Missing hydrographs for RDII: '
                                + ', '.join([str(x) for x in misshing_U_H])
                                + '. \nPlease check if the correct file was selected '
                                + 'and the \"Hydrographs\" table is set up correctly. '
                                + 'The RDII section will not be written into the input file '
                                + 'to avoid errors in SWMM.'
                            )
                        else:
                            inp_dict['RDII'] = {'data': rdii_df}
        feedback.setProgress(55)

        # Streets and inlets
        if 'streets' in export_data.keys():
            feedback.setProgressText(self.tr('[STREETS] and [INLETS] section'))
            from .g_s_links import get_street_from_tables
            streets_df, inlets_df, inlet_usage_df = get_street_from_tables(
                raw_data_dict['streets']
            )
            if len(streets_df) > 0:
                inp_dict['STREETS'] = {'data': streets_df}
            if len(inlets_df) > 0:
                inp_dict['INLETS'] = {'data': inlets_df}
            if len(inlet_usage_df) > 0:
                inp_dict['INLET_USAGE'] = {'data': inlet_usage_df}

        # Curves
        if 'curves' in export_data.keys():
            feedback.setProgressText(self.tr('[CURVES] section'))
            from .g_s_export_helpers import get_curves_from_table
            inp_dict['CURVES'] = {
                'data': get_curves_from_table(
                    raw_data_dict['curves'],
                    name_col='Name'
                )
            }
        feedback.setProgress(60)

        # patterns
        if 'patterns' in export_data.keys():
            feedback.setProgressText(self.tr('[PATTERNS] section'))
            from .g_s_export_helpers import get_patterns_from_table
            inp_dict['PATTERNS'] = {
                'data': get_patterns_from_table(
                    raw_data_dict['patterns'],
                    name_col='Name'
                )
            }
        feedback.setProgress(65)

        # time series
        if 'timeseries' in export_data.keys():
            feedback.setProgressText(self.tr('[TIMESERIES] section'))
            from .g_s_export_helpers import get_timeseries_from_table
            inp_dict['TIMESERIES'] = {
                'data': get_timeseries_from_table(
                    raw_data_dict['timeseries'],
                    name_col='Name',
                    feedback=feedback
                )
            }
        feedback.setProgress(70)

        # rain gages
        from .g_s_subcatchments import get_raingage_from_qgis_row
        if 'raingages_raw' in export_data.keys():
            feedback.setProgressText(self.tr('[RAINGAGES] section'))
            rg_cols = list(def_qgis_fields_dict['RAINGAGES'].keys())
            rg_features_df = raw_data_dict['raingages_raw']
            check_columns(
                file_raingages,
                rg_cols,
                rg_features_df.columns
            )
            raingages_annot = get_annotations_from_raw_df(
                rg_features_df
            )
            rg_features_df = rg_features_df.apply(
                lambda x: get_raingage_from_qgis_row(x),
                axis=1
            )
            rg_symbols_df = get_coords_from_geometry(rg_features_df)
            rg_symbols_df.drop("Z_Coord", axis=1, inplace=True)
            rg_inp_cols = def_sections_dict['RAINGAGES']
            rg_features_df = rg_features_df[rg_inp_cols]  # drop unnecessary
            inp_dict['RAINGAGES'] = {
                'data': rg_features_df,
                'annotations': raingages_annot
            }
            inp_dict['SYMBOLS'] = {'data': rg_symbols_df}

        # quality
        if 'quality' in export_data.keys():
            feedback.setProgressText(self.tr('[POLLUTANTS] and [LANDUSES] section'))
            from .g_s_quality import get_quality_params_from_table
            if 'SUBCATCHMENTS' in inp_dict.keys():
                inp_dict['QUALITY'] = {
                    'data': get_quality_params_from_table(
                        raw_data_dict['quality'],
                        inp_dict['SUBCATCHMENTS']['data'].copy()
                    )
                }
            else:
                inp_dict['QUALITY'] = {
                    'data': get_quality_params_from_table(
                        raw_data_dict['quality']
                    )
                }
        feedback.setProgressText(self.tr('done \n'))
        feedback.setProgress(80)

        # writing inp file
        feedback.setProgressText(self.tr('Creating inp file:'))
        inp_dict = {k: v for k, v in inp_dict.items() if len(v['data']) > 0}  # remove empty sections
        from .g_s_write_inp import write_inp
        write_inp(inp_file_name,
                  project_dir,
                  inp_dict,
                  feedback)
        feedback.setProgress(98)
        feedback.setProgressText(
            self.tr(
                'input file saved in ' + str(os.path.join(
                    project_dir,
                    inp_file_name)
                )
            )
        )
        return {}

    def shortHelpString(self):
        return self.tr(""" With this tool you can write a swmm input file based on QGIS layers (and supplementary data in .xslx files).\n
        The column names within attribute tables have to be the same as in the default data set.
        Proposed workflow:\n
        1) load default data with the first tool.\n
        2) copy all files to a new folder and edit the data set.\n
        3) select the edited layers / files to create the input file (.inp)\n
        4) run the input file in swmm
        """)

    def name(self):
        return 'GenerateSwmmInpFile'

    def displayName(self):
        return self.tr('2_GenerateSwmmInpFile')

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return GenerateSwmmInpFile()
