# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'


# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import pandas as pd
import numpy as np
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProject,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterString,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterVectorLayer,
                       QgsVectorFileWriter)
from .g_s_read_write_data  import read_layers_direct
from .g_s_defaults import def_ogr_driver_names, def_ogr_driver_dict

class SelectSubModel(QgsProcessingAlgorithm):
    """
    generates a swmm input file from geodata and tables
    """
    OPTION_ABOVE_BELOW = 'OPTION_ABOVE_BELOW'
    SAVE_FOLDER = 'SAVE_FOLDER'
    PREFIX = 'PREFIX'
    FILE_RAINGAGES = 'FILE_RAINGAGES'
    FILE_CONDUITS = 'FILE_CONDUITS'
    FILE_JUNCTIONS = 'FILE_JUNCTIONS'
    FILE_DIVIDERS = 'FILE_DIVIDERS'
    FILE_ORIFICES = 'FILE_ORIFICES'
    FILE_OUTFALLS = 'FILE_OUTFALLS'
    FILE_OUTLETS = 'FILE_OUTLETS'
    FILE_STORAGES = 'FILE_STORAGES'
    FILE_PUMPS    = 'FILE_PUMPS'
    FILE_SUBCATCHMENTS= 'FILE_SUBCATCHMENTS'
    FILE_WEIRS = 'FILE_WEIRS'
    
    
    def initAlgorithm(self, config):
        """
        inputs and output of the algorithm
        """
        self.addParameter(
            QgsProcessingParameterEnum(
                self.OPTION_ABOVE_BELOW,
                self.tr('Selection type'),
                ['Model parts above selected node','Exclude model parts above selected node'],
                optional = False,
                defaultValue = 0
                ))
                
        self.addParameter(
            QgsProcessingParameterFolderDestination(
            self.SAVE_FOLDER,
            self.tr('Folder in which the new model files will be saved.')
            )
        )
        
        self.addParameter(
            QgsProcessingParameterString(
            self.PREFIX,
            self.tr('Prefix for new data'),
            optional = True
            )
        )
        
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_RAINGAGES,
                self.tr('Rain gages Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_Raingagges'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_JUNCTIONS,
                self.tr('Junctions Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_junctions'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_CONDUITS,
                self.tr('Conduits Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_conduits'
                ))
        
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_SUBCATCHMENTS,
                self.tr('Subcatchments Layer'),
                types=[QgsProcessing.SourceType.TypeVectorAnyGeometry],
                optional = True#,defaultValue = 'SWMM_subcatchments'
                ))
        
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_STORAGES,
                self.tr('Storages Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_storages'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_OUTFALLS,
                self.tr('Outfalls Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_outfalls'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_DIVIDERS,
                self.tr('Dividers Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_dividers'
                ))
                
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_PUMPS,
                self.tr('Pumps Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_Pumps'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_WEIRS,
                self.tr('Weirs Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_weirs'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_ORIFICES,
                self.tr('Orifices Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_orifices'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_OUTLETS,
                self.tr('Outlets Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_outlets'
                ))
                
    def name(self):
        return 'SelectSubModel'
        
    def shortHelpString(self):
        return self.tr(""" The tool selects a subset of features in the chosen SWMM layers in order to create a new model\n
        Option 1: select features above a certain node \n
        Option 2: everything except features from Option 1 \n
        """)

    def displayName(self):
        return self.tr('4_SelectSubModel')

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return SelectSubModel()
        
    def processAlgorithm(self, parameters, context, feedback):  
        above_or_below = self.parameterAsInt(parameters, self.OPTION_ABOVE_BELOW, context) # 0=above, 1=below
        # reading geodata
        feedback.setProgressText(self.tr('Reading layers'))
        feedback.setProgress(1)
        folder_save = self.parameterAsString(parameters, self.SAVE_FOLDER, context)
        if parameters['SAVE_FOLDER'] == 'TEMPORARY_OUTPUT':
            raise QgsProcessingException('The data set needs to be saved in a directory (temporary folders wonÂ´t work). Please select a directoy')
        result_prefix = self.parameterAsString(parameters, self.PREFIX, context)
        file_raingages = self.parameterAsVectorLayer(parameters, self.FILE_RAINGAGES, context)
        file_outfalls = self.parameterAsVectorLayer(parameters, self.FILE_OUTFALLS, context)
        file_storages = self.parameterAsVectorLayer(parameters, self.FILE_STORAGES, context)
        file_subcatchments = self.parameterAsVectorLayer(parameters, self.FILE_SUBCATCHMENTS, context)
        file_conduits = self.parameterAsVectorLayer(parameters, self.FILE_CONDUITS, context)
        file_junctions = self.parameterAsVectorLayer(parameters, self.FILE_JUNCTIONS, context)
        file_pumps = self.parameterAsVectorLayer(parameters, self.FILE_PUMPS, context)
        file_weirs = self.parameterAsVectorLayer(parameters, self.FILE_WEIRS, context)
        file_orifices = self.parameterAsVectorLayer(parameters, self.FILE_ORIFICES, context)
        file_outlets = self.parameterAsVectorLayer(parameters, self.FILE_OUTLETS, context)
        file_dividers = self.parameterAsVectorLayer(parameters, self.FILE_DIVIDERS, context)
        
        
        # create layer dictionaries
        nodes_layers_dict = {
            'junctions_raw':file_junctions,
            'outfalls_raw':file_outfalls,
            'storages_raw':file_storages,
            'dividers_raw':file_dividers
        }
        nodes_layers_dict = {k:v for k,v in nodes_layers_dict.items() if v is not None}
        
        link_layers_dict = {
            'conduits_raw': file_conduits,
            'pumps_raw':file_pumps,
            'weirs_raw':file_weirs,
            'orifices_raw':file_orifices,
            'outlets_raw':file_outlets
        }
        link_layers_dict = {k:v for k,v in link_layers_dict.items() if v is not None}
        
        subcatch_layers_dict = {
            'subcatchments_raw':file_subcatchments
        }
        subcatch_layers_dict = {k:v for k,v in subcatch_layers_dict.items() if v is not None}

        
        raingages_layer_dict = {
            'raingages_raw':file_raingages
        }
        raingages_layer_dict = {k:v for k,v in raingages_layer_dict.items() if v is not None}
        
        
        if len(nodes_layers_dict) == 0:
            raise QgsProcessingException('You need at least one node layer')
        else:
            # get startpoint...
            start_point = ''
            for p_f in nodes_layers_dict.values():
                if feedback.isCanceled():
                        break
                s_f_c = p_f.selectedFeatureCount()
                if s_f_c == 1:
                    if start_point == '':
                        start_point = p_f.selectedFeatures()[0].attribute('Name')
                        start_point_file = p_f.name()
                    else:
                        raise QgsProcessingException('There is more than one point selected in total (in different layers): ' + str(start_point_file)+ ', '+str(p_f.name())+'. Only one selected point is allowed for this tool!')
                if s_f_c > 1:
                    raise QgsProcessingException('There is more than one point selected in layer ' +str(p_f.name())+'. Only one selected point is allowed for this tool!')
            if start_point == '':
                raise QgsProcessingException('No selected Node. Please select one node in the node layers')
            # load and merge node layers as pd.df
            needed_nodes_attrs = ['Name']
            nodes_df_dict = read_layers_direct(
                nodes_layers_dict,
                needed_nodes_attrs,
                with_id = True
            )
            all_nodes_df = pd.concat([l for l in nodes_df_dict.values()])
            all_nodes_df = all_nodes_df[needed_nodes_attrs+['id']]
            all_nodes_df = all_nodes_df.reset_index()

        feedback.setProgressText(self.tr('done \n'))
        feedback.setProgress(12)

        if len(link_layers_dict) == 0:
            # if no links exist, then select only the startpoint
            nodes_route = [start_point]
        else:
            # load and merge link layers as pd.df
            needed_link_attrs = ['Name','FromNode','ToNode']
            links_df_dict = read_layers_direct(
                link_layers_dict,
                needed_link_attrs,
                with_id = True
            )
            all_links_df = pd.concat([l for l in links_df_dict.values()])
            all_links_df = all_links_df[needed_link_attrs+['id']]
            all_links_df = all_links_df.reset_index()
            
            

            
            StartMarker = start_point
            links_route = [] 
            nodes_route = []


            # find flow path upstream or downstream
            Marker = StartMarker # Name of first segment
            safe=["X"] #a list to safe segments when the net separates; "X" indicates an empty list and works as a Marker for the while loop below
            origins = [] # a list for origins/river heads upstream

            while str(Marker) != 'X':
                if feedback.isCanceled():
                    break
                next_rows = np.where(Marker == all_links_df['ToNode'])[0].tolist()
                if len (next_rows) > 0: # sometimes segments are saved in links_route...then they are deleted
                    for Z in next_rows: 
                        if all_links_df.loc[Z,'Name'] in links_route:
                            next_rows.remove(Z)
                    links_route = links_route + all_links_df.loc[next_rows,'Name'].tolist()
                    nodes_from_names = all_links_df.loc[next_rows,'FromNode'].tolist()
                    nodes_route = nodes_route + nodes_from_names
                if len(next_rows) > 1:
                    Marker = all_links_df.loc[next_rows[0],'FromNode']
                    safe = safe + all_links_df.loc[next_rows[1:],'FromNode'].tolist()
                if len(next_rows) == 1:
                    Marker = all_links_df.loc[next_rows[0],'FromNode']
                if len(next_rows) == 0:
                    origins = origins + [Marker]
                    Marker = safe[-1] #change Marker to the last "saved" FromNode
                    safe=safe[:-1] #delete used FromNode from "safe"-list
            
            # delete duplicate nodes
            nodes_route = list(np.unique(nodes_route))
            
            # check for splitting nodes
            links_not_above = all_links_df.loc[~np.isin(all_links_df['Name'].to_list(), links_route),:]
            
            # required nodes for 'not_above'
            nodes_route_2 = list(links_not_above['FromNode'])+list(links_not_above['ToNode'])
            nodes_route_2 = list(np.unique(nodes_route_2))
        
            # check for "splitting" nodes
            splitting_nodes = [str(f) for f in nodes_route_2 if f in nodes_route]
            if len(splitting_nodes) > 0:
                feedback.reportError("Warning: the network is splitting at :"+", ".join(splitting_nodes))
            
            if above_or_below == 1: # below
                links_route = list(links_not_above['Name'])
                nodes_route = nodes_route_2
            else:
                '''in the future: create outfall for export'''
                pass 
        
        # check if all requires nodes are in nodes_route
        nodes_exist_dict = {n:(n in all_nodes_df['Name'].to_list()) for n in nodes_route}
        if all(nodes_exist_dict.values()):
            pass
        else:
            missing_nodes = [str(k) for k,v in nodes_exist_dict.items() if not v]
            raise QgsProcessingException('Missing nodes for submodel: '+', '.join(missing_nodes)+'. Please check if all required layers were selected')

        
        ## select line layers
        if len(link_layers_dict) == 0:
            pass
        else:
            for layer_n, vector_layer in link_layers_dict.items():
                layer_n_attrs = links_df_dict[layer_n]
                features_for_selection = list(layer_n_attrs.loc[layer_n_attrs['Name'].isin(links_route),'id'])
                sel=[]
                while len(features_for_selection) != 0:
                    if feedback.isCanceled():
                        break
                    set1 = features_for_selection[:200]
                    sel = sel+[set1]
                    features_for_selection = features_for_selection[200:]
                vector_layer.removeSelection()
                for selSet in sel:
                    vector_layer.selectByIds(selSet, vector_layer.SelectBehavior(1))
        
        ## select point layers
        for layer_n, vector_layer in nodes_layers_dict.items():
            layer_n_attrs = nodes_df_dict[layer_n]
            features_for_selection = list(layer_n_attrs.loc[layer_n_attrs['Name'].isin(nodes_route),'id'])
            sel=[]
            while len(features_for_selection) != 0:
                set1 = features_for_selection[:200]
                sel = sel+[set1]
                features_for_selection = features_for_selection[200:]
            vector_layer.removeSelection()
            for selSet in sel:
                vector_layer.selectByIds(selSet, vector_layer.SelectBehavior(1))
                
        # subcatchments
        if len(subcatch_layers_dict) != 0:
            feedback.setProgressText(self.tr('Selecting subcatchments'))
            ## load subcatchment layer as pd.df
            needed_subc_attrs = ['Name','Outlet','RainGage']
            subc_df_dict = read_layers_direct(
                subcatch_layers_dict,
                needed_subc_attrs,
                with_id = True
            )
            subc_df = subc_df_dict['subcatchments_raw'][needed_subc_attrs+['id']]
            
            ## select subcatchments
            sc_for_selection = subc_df.loc[subc_df['Outlet'].isin(nodes_route),:]
            features_for_selection = list(sc_for_selection['id'])
            sel=[]
            while len(features_for_selection) != 0:
                set1 = features_for_selection[:200]
                sel = sel+[set1]
                features_for_selection = features_for_selection[200:]
            file_subcatchments.removeSelection()
            for selSet in sel:
                file_subcatchments.selectByIds(selSet, file_subcatchments.SelectBehavior(1))
            feedback.setProgressText(self.tr('done'))
            
            
            # raingages
            if len(raingages_layer_dict) != 0:
                feedback.setProgressText(self.tr('Selecting raingages'))
                ## load raingages layer as pd df
                needed_rg_attrs = ['Name']
                rg_df_dict = read_layers_direct(
                    raingages_layer_dict,
                    needed_rg_attrs,
                    with_id = True
                )
                rg_df = rg_df_dict['raingages_raw'][needed_rg_attrs+['id']]
                    
                ## select raingages
                required_rangages = list(np.unique(sc_for_selection['RainGage']))
                features_for_selection = list(rg_df.loc[rg_df['Name'].isin(required_rangages),'id'])
                sel=[]
                while len(features_for_selection) != 0:
                    set1 = features_for_selection[:200]
                    sel = sel+[set1]
                    features_for_selection = features_for_selection[200:]
                file_raingages.removeSelection()
                for selSet in sel:
                    file_raingages.selectByIds(selSet, file_raingages.SelectBehavior(1))
                feedback.setProgressText(self.tr('done'))
        
        # vector_layer = file_conduits
        # layer_name = 'test'
        # geodata_driver_num = 0
        # geodata_driver_name = def_ogr_driver_names[geodata_driver_num]
        # geodata_driver_extension = def_ogr_driver_dict[geodata_driver_name]
        # # create layer
        # options = QgsVectorFileWriter.SaveVectorOptions()
        # options.fileEnconding = 'utf-8'
        # options.driverName = geodata_driver_name
        # options.onlySelectedFeatures = True
        # transform_context = QgsProject.instance().transformContext()
        # QgsVectorFileWriter.writeAsVectorFormatV3(
            # vector_layer,
            # os.path.join(folder_save,layer_name+'.'+geodata_driver_extension),
            # transform_context,
            # options
        # )
        
        return {}







