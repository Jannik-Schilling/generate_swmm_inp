# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'


# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import pandas as pd
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterVectorLayer)
from .g_s_various_functions import check_columns
from .g_s_read_write_data  import read_layers_direct

class SelectSubModel(QgsProcessingAlgorithm):
    """
    generates a swmm input file from geodata and tables
    """
    OPTION_CREATE_DELETE = 'OPTION_CREATE_DELETE'
    FILE_RAINGAGES = 'FILE_RAINGAGES'
    FILE_CONDUITS = 'FILE_CONDUITS'
    FILE_JUNCTIONS = 'FILE_JUNCTIONS'
    FILE_DIVIDERS = 'FILE_DIVIDERS'
    FILE_ORIFICES = 'FILE_ORIFICES'
    FILE_OUTFALLS = 'FILE_OUTFALLS'
    FILE_OUTLETS = 'FILE_OUTLETS'
    FILE_STORAGES = 'FILE_STORAGES'
    FILE_PUMPS    = 'FILE_PUMPS'
    FILE_SUBCATCHMENTS= 'FILE_SUBCATCHMENTS'
    FILE_WEIRS = 'FILE_WEIRS'
    
    
    def initAlgorithm(self, config):
        """
        inputs and output of the algorithm
        """
        self.addParameter(
            QgsProcessingParameterEnum(
                self.OPTION_ABOVE_BELOW,
                self.tr('Rain gages Layer'),
                ['Create submodel above selected point','Exclude model parts above selected Point'],
                optional = False,
                defaultValue = 0
                ))
                
        self.addParameter(
            QgsProcessingParameterFolderDestination(
            self.SAVE_FOLDER,
            self.tr('Folder in which the new model files will be saved.')
            )
        )
        
        self.addParameter(
            QgsProcessingParameterString(
            self.PREFIX,
            self.tr('Prefix for new data'),
            optional = True
            )
        )
        
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_RAINGAGES,
                self.tr('Rain gages Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_Raingagges'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_JUNCTIONS,
                self.tr('Junctions Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_junctions'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_CONDUITS,
                self.tr('Conduits Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_conduits'
                ))
        
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_SUBCATCHMENTS,
                self.tr('Subcatchments Layer'),
                types=[QgsProcessing.SourceType.TypeVectorAnyGeometry],
                optional = True#,defaultValue = 'SWMM_subcatchments'
                ))
        
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_STORAGES,
                self.tr('Storages Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_storages'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_OUTFALLS,
                self.tr('Outfalls Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_outfalls'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_DIVIDERS,
                self.tr('Dividers Layer'),
                types=[QgsProcessing.SourceType.TypeVectorPoint],
                optional = True#,defaultValue = 'SWMM_dividers'
                ))
                
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_PUMPS,
                self.tr('Pumps Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_Pumps'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_WEIRS,
                self.tr('Weirs Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_weirs'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_ORIFICES,
                self.tr('Orifices Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_orifices'
                ))
                
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.FILE_OUTLETS,
                self.tr('Outlets Layer'),
                types=[QgsProcessing.SourceType.TypeVectorLine],
                optional = True#,defaultValue = 'SWMM_outlets'
                ))
                
    def processAlgorithm(self, parameters, context, feedback):  
        """
        """
        # reading geodata
        feedback.setProgressText(self.tr('Reading layers'))
        feedback.setProgress(1)
        folder_save = self.parameterAsString(parameters, self.SAVE_FOLDER, context)
        if parameters['SAVE_FOLDER'] == 'TEMPORARY_OUTPUT':
            raise QgsProcessingException('The data set needs to be saved in a directory (temporary folders wonÂ´t work). Please select a directoy')
        result_prefix = self.parameterAsString(parameters, self.PREFIX, context)
        file_raingages = self.parameterAsVectorLayer(parameters, self.FILE_RAINGAGES, context)
        file_outfalls = self.parameterAsVectorLayer(parameters, self.FILE_OUTFALLS, context)
        file_storages = self.parameterAsVectorLayer(parameters, self.FILE_STORAGES, context)
        file_subcatchments = self.parameterAsVectorLayer(parameters, self.FILE_SUBCATCHMENTS, context)
        file_conduits = self.parameterAsVectorLayer(parameters, self.FILE_CONDUITS, context)
        file_junctions = self.parameterAsVectorLayer(parameters, self.FILE_JUNCTIONS, context)
        file_pumps = self.parameterAsVectorLayer(parameters, self.FILE_PUMPS, context)
        file_weirs = self.parameterAsVectorLayer(parameters, self.FILE_WEIRS, context)
        file_orifices = self.parameterAsVectorLayer(parameters, self.FILE_ORIFICES, context)
        file_outlets = self.parameterAsVectorLayer(parameters, self.FILE_OUTLETS, context)
        file_dividers = self.parameterAsVectorLayer(parameters, self.FILE_DIVIDERS, context)
        
        # get startpoint
        start_point = ''
        for p_f in [
            file_junctions,
            file_outfalls,
            file_storages,
            file_raingages,
            file_dividers
        ]:
            s_f_c = p_f.selectedFeatureCount()
            if s_f_c == 1:
                if start_point == '':
                    start_point = p_f.selectedFeatures()[0].attribute('Name')
                    start_point_file = p_f.name()
                else:
                    raise QgsProcessingException('There is more than one point selected in total (in different layers): ' + str(start_point_file)+ ', '+str(p_f.name())+'. Only one selected point is allowed for this tool!')
            if s_f_c > 1:
                raise QgsProcessingException('There is more than one points selected in layer ' +str(p_f.name())+'. Only one selected point is allowed for this tool!')

        # load and merge line layers as pd.df
        line_layers_dict = {
            'conduits_raw': file_conduits,
            'pumps_raw':file_pumps,
            'weirs_raw':file_weirs,
            'orifices_raw':file_orifices,
            'outlets_raw':file_outlets
        }
        needed_line_attrs = ['Name','FromNode','ToNode']
        lines_df_dict = read_layers_direct(
            line_layers_dict,
            needed_line_attrs,
            with_id = True
        )
        all_lines_df = pd.concat([l for l in lines_df_dict.values()])
        all_lines_df = all_lines_df[needed_line_attrs+['id']]
        all_lines_df = all_lines_df.reset_index()
        
        # load subcatchment layer as pd.df
        subcatch_layers_dict = {
            'subcatchments_raw':file_subcatchments
        }
        needed_subc_attrs = ['Name','RainGage']
        subc_df_dict = read_layers_direct(
            subcatch_layers_dict,
            needed_subc_attrs,
            with_id = True
        )
        subc_df = subc_df_dict['subcatchments_raw'][needed_subc_attrs+['id']]
        
        # load and merge node layers as pd.df
        nodes_layers_dict = {
            'junctions_raw':file_junctions,
            'outfalls_raw':file_outfalls,
            'storages_raw':file_storages,
            'raingages_raw':file_raingages,
            'dividers_raw':file_dividers
        }
        needed_nodes_attrs = ['Name']
        nodes_df_dict = read_layers_direct(
            nodes_layers_dict,
            needed_nodes_attrs,
            with_id = True
        )
        all_points_df = pd.concat([l for l in nodes_df_dict.values()])
        all_points_df = all_lines_df[needed_nodes_attrs+['id']]
        all_points_df = all_points_df.reset_index()
        
        feedback.setProgressText(self.tr('done \n'))
        feedback.setProgress(12)
        
        StartMarker = start_point
        lines_route = []
        points_route = []



        '''find flow path upstream or downstream'''
        Marker = StartMarker # Name of first segment
        safe=["X"] #a list to safe segments when the net separates; "X" indicates an empty list and works as a Marker for the while loop below
        origins = [] # a list for origins/river heads upstream

        while str(Marker) != 'X':
            next_rows = np.where(Marker == all_lines_df['ToNode'])[0].tolist()
            if len (next_rows) > 0: # sometimes segments are saved in lines_route...then they are deleted
                for Z in next_rows: 
                    if all_lines_df.loc[Z,'Name'] in lines_route:
                        next_rows.remove(Z)
                lines_route = lines_route + all_lines_df.loc[next_rows,'Name'].tolist()
                points_from_names = all_lines_df.loc[next_rows,'FromNode'].tolist()
                points_route = points_route + points_from_names
            if len(next_rows) > 1:
                Marker = all_lines_df.loc[next_rows[0],'FromNode']
                safe = safe + all_lines_df.loc[next_rows[1:],'FromNode'].tolist()
            if len(next_rows) == 1:
                Marker = all_lines_df.loc[next_rows[0],'FromNode']
            if len(next_rows) == 0:
                origins = origins + [Marker]
                Marker = safe[-1] #change Marker to the last "saved" FromNode
                safe=safe[:-1] #delete used FromNode from "safe"-list

        ## select line layers
        ## select point layers
        ## select subcatchments
        ## (if at least one selected)
        
        # sel=[]
        # while len(conduits_route) != 0:
            # set1=conduits_route[:200]
            # sel=sel+[set1]
            # conduits_route=conduits_route[200:]
        # conduits.removeSelection()
        # for selSet in sel:
            # conduits.selectByIds(selSet, conduits.SelectBehavior(1))
            
        
        ## if create submodel
            ## if start_point is not an outfall create outfall
            
        # export selected with prefix








