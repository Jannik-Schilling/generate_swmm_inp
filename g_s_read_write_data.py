# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'



import pandas as pd
import os
import numpy as np
from qgis.core import (NULL,
                       QgsProcessingException)

def read_shapefiles_direct(file_outfalls,
                       file_storages,
                       file_subcatchments,
                       file_conduits,
                       file_junctions,
                       file_pumps,
                       file_weirs,
                       file_orifices,
                       file_outlets,
                       file_dividers):
    """reads shapefiles from swmm model"""
    data_dict = dict()
    def del_none_bool(df):
        """
        replaces None or NULL with np.nan
        replaces True and False with 'YES' and 'NO'
        ...except of geometry column
        """
        df[df.columns[:-1]] =  df[df.columns[:-1]].fillna(value=np.nan)
        def replace_null_nan(atrr_value):
            if atrr_value == NULL:
                return np.nan
            else:
                return atrr_value
        df = df.applymap(replace_null_nan)
        df[df.columns[:-1]] =  df[df.columns[:-1]].replace('True','YES').replace('False','NO')
        return df
    def load_shapefile_to_df(vlayer):
        """reads shapefile attributes and geometries"""
        cols = [f.name() for f in vlayer.fields()]
        # check for null geometries
        if any(not(f.hasGeometry()) for f in vlayer.getFeatures()):
            name_missing_geom = [f['Name'] for f in vlayer.getFeatures() if not(f.hasGeometry())]
            raise QgsProcessingException('Failed to load layer: missing geometries in '+vlayer.name()+': '+', '.join(name_missing_geom))
        datagen = ([f[col] for col in cols]+[f.geometry()] for f in vlayer.getFeatures())
        df = pd.DataFrame.from_records(data=datagen, columns=cols+['geometry'])
        return df
        
    if file_outfalls is not None:
        data_dict['outfalls_raw'] = load_shapefile_to_df(file_outfalls)
    
    if file_storages is not None:
        data_dict['storages_raw'] = load_shapefile_to_df(file_storages)
    
    if file_subcatchments is not None:
        data_dict['subcatchments_raw'] = load_shapefile_to_df(file_subcatchments)
    
    if file_conduits is not None:
        data_dict['conduits_raw'] = load_shapefile_to_df(file_conduits)
    
    if file_junctions is not None:
        data_dict['junctions_raw'] = load_shapefile_to_df(file_junctions)
    
    if file_pumps is not None:
        data_dict['pumps_raw'] = load_shapefile_to_df(file_pumps)
    
    if file_outlets is not None:
        data_dict['outlets_raw'] = load_shapefile_to_df(file_outlets)
    
    if file_orifices is not None:
        data_dict['orifices_raw'] = load_shapefile_to_df(file_orifices)
    
    if file_weirs is not None:
        data_dict['weirs_raw'] = load_shapefile_to_df(file_weirs)
    
    if file_dividers is not None:
        data_dict['dividers_raw'] = load_shapefile_to_df(file_dividers)
    data_dict = {key_i:del_none_bool(data_dict[key_i]) for key_i in data_dict.keys()}
    return data_dict

    
def read_data_from_table_direct(file, sheet=0): 
    '''reads curves or other tables from excel or csv'''
    filename, file_extension = os.path.splitext(file)
    if file_extension == '.xlsx' or file_extension == '.xls' or file_extension == '.ods':
        if sheet == 0:
            data_df = pd.read_excel(file,sheet_name = sheet)
        else:
            #print ('sheet not 0')
            if sheet in pd.ExcelFile(file).sheet_names:
                data_df = pd.read_excel(file,sheet_name = sheet)
            elif str(sheet).upper() in pd.ExcelFile(file).sheet_names:
                data_df = pd.read_excel(file,sheet_name = str(sheet).upper())
            elif str(sheet).lower() in pd.ExcelFile(file).sheet_names:
                data_df = pd.read_excel(file,sheet_name = str(sheet).lower())
            elif str(sheet).capitalize() in pd.ExcelFile(file).sheet_names:
                data_df = pd.read_excel(file,sheet_name = str(sheet).capitalize())
            else:
                data_df = pd.DataFrame()
    if file_extension == '.csv':
        data_df = pd.read_csv(file)
    return data_df
    
    
""" Excel files """
def dict_to_excel(data_dict, save_name, feedback, res_prefix = '', desired_format = None):
    """
    writes an excel file from a data_dict
    :param dict data_dict
    :param str save_name
    :param str res_prefix: prefix for file name
    """
    if res_prefix != '':
        save_name = res_prefix+'_'+save_name
    if desired_format is not None:
        try:
            save_name = save_name+desired_format
            with pd.ExcelWriter(os.path.join(folder_save, save_name)) as writer:
                for sheet_name, df in data_dict.items():
                    df.to_excel(writer, sheet_name=sheet_name,index = False)
        except:
            raise QgsProcessingException(self.tr('Could not write tables in the desired file format. Please install the package "openpyxl" (or alternatively the package "odf"). Instructions can be found on the in the documentation or on GitHub (https://github.com/Jannik-Schilling/generate_swmm_inp)'))
    else:
        try:
            save_name_xlsx = save_name+'.xlsx'
            with pd.ExcelWriter(os.path.join(folder_save, save_name_xlsx)) as writer:
                for sheet_name, df in data_dict.items():
                    df.to_excel(writer, sheet_name=sheet_name,index = False)
        except:
            try:
                save_name_xls = save_name+'.xls'
                with pd.ExcelWriter(os.path.join(folder_save, save_name_xls)) as writer:
                    for sheet_name, df in data_dict.items():
                        df.to_excel(writer, sheet_name=sheet_name,index = False)
            except:
                try:
                    save_name_ods = save_name+'.ods'
                    with pd.ExcelWriter(os.path.join(folder_save, save_name_ods)) as writer:
                        for sheet_name, df in data_dict.items():
                            df.to_excel(writer, sheet_name=sheet_name,index = False)
                except:
                    raise QgsProcessingException(self.tr('Could not write tables in .xlsx, .xls, or .ods format. Please install the package "openpyxl" (or alternatively the package "odf"). Instructions can be found on the in the documentation or on GitHub (https://github.com/Jannik-Schilling/generate_swmm_inp)'))
