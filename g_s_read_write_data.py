# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'



import pandas as pd
import os
import numpy as np
from qgis.core import (NULL,
                       QgsFeature,
                       QgsField,
                       QgsProcessingException,
                       QgsProject,
                       QgsVectorFileWriter,
                       QgsVectorLayer)

from qgis.PyQt.QtCore import QVariant
from .g_s_defaults import (
    def_ogr_driver_names,
    def_ogr_driver_dict,
    def_sections_geoms_dict,
    def_qgis_fields_dict
)



def read_layers_direct(raw_layers_dict):
    """reads layers from swmm model"""
    
    def del_none_bool(df):
        """
        replaces None or NULL with np.nan
        replaces True and False with 'YES' and 'NO'
        except of geometry column
        :param pd.DataFrame df
        """
        df[df.columns[:-1]] =  df[df.columns[:-1]].fillna(value=np.nan)
        def replace_null_nan(atrr_value):
            if atrr_value == NULL:
                return np.nan
            else:
                return atrr_value
        df = df.applymap(replace_null_nan)
        df[df.columns[:-1]] =  df[df.columns[:-1]].replace('True','YES').replace('False','NO')
        return df
    def load_layer_to_df(vlayer):
        """
        reads layer attributes and geometries
        :param QgsVectorLayer vlayer
        """
        cols = [f.name() for f in vlayer.fields()]
        # check for null geometries
        if any(not(f.hasGeometry()) for f in vlayer.getFeatures()):
            name_missing_geom = [f['Name'] for f in vlayer.getFeatures() if not(f.hasGeometry())]
            raise QgsProcessingException('Failed to load layer: missing geometries in '+vlayer.name()+': '+', '.join(name_missing_geom))
        datagen = ([f[col] for col in cols]+[f.geometry()] for f in vlayer.getFeatures())
        df = pd.DataFrame.from_records(data=datagen, columns=cols+['geometry'])
        return df
    data_dict = {n: load_layer_to_df(d) for n, d in raw_layers_dict.items() if d is not None}
    data_dict_out = {n:d for n, d in data_dict.items() if len(d) > 0}
    data_dict_out = {n:del_none_bool(data_dict_out[n]) for n in data_dict_out.keys()}
    return data_dict_out
    
    
    


def create_feature_from_df(df, pr, geom_type):
    """
    creates a QgsFeature from data in df
    :param pd.DataFrame df
    :param QgsVectorLayer.dataProvider() pr
    """
    f = QgsFeature()
    if geom_type != 'NoGeometry':
        f.setGeometry(df.geometry)
    f.setAttributes(df.tolist()[:-1])
    pr.addFeature(f)

                                                     

def create_layer_from_table(
    data_df,
    section_name,
    layer_name, 
    crs_result,
    folder_save,
    geodata_driver_num,
    custom_fields = None):

    """
    creates a QgsVectorLayer from data in data_df
    :param pd.DataFrame data_df
    :param str section_name: name of SWMM section
    :param str layer_name
    :param str crs_result: epsg code of the desired CRS
    :param str folder_save
    :param int geodata_driver_num: key of driver in def_ogr_driver_dict
    :param dict costum fields
    """
    # set driver
    geodata_driver_name = def_ogr_driver_names[geodata_driver_num]
    geodata_driver_extension = def_ogr_driver_dict[geodata_driver_name]
    
    # set geometry type and provider
    geom_type = def_sections_geoms_dict[section_name]
    vector_layer = QgsVectorLayer(geom_type,layer_name,'memory')
    v_l_crs = vector_layer.crs()
    v_l_crs.createFromUserInput(crs_result)
    vector_layer.setCrs(v_l_crs)
    pr = vector_layer.dataProvider()
    
    # set fields
    field_types_dict = {'Double':QVariant.Double,
                        'String':QVariant.String,
                        'Int':QVariant.Int,
                        'Bool': QVariant.Bool}
    layer_fields = def_qgis_fields_dict[section_name]
    if custom_fields is not None:
        layer_fields.update(custom_fields)
    for col in layer_fields:
        field_type_string = layer_fields[col]
        field_type = field_types_dict[field_type_string]
        pr.addAttributes([QgsField(col, field_type)])
    vector_layer.updateFields()
    data_df.apply(lambda x: create_feature_from_df(x, pr, geom_type), axis =1)
    vector_layer.updateExtents()
    
    # create layer
    try:
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.fileEnconding = 'utf-8'
        options.driverName = geodata_driver_name
        transform_context = QgsProject.instance().transformContext()
        QgsVectorFileWriter.writeAsVectorFormatV3(
            vector_layer,
            os.path.join(folder_save,layer_name+'.'+geodata_driver_extension),
            transform_context,
            options
        )
    except:
        # for older QGIS versions
        QgsVectorFileWriter.writeAsVectorFormat(
            vector_layer,
            os.path.join(folder_save,layer_name+'.'+geodata_driver_extension),
            'utf-8',
            vector_layer.crs(),
            driverName=geodata_driver_name
        )
    return vector_layer
            
            
            
            
    
def read_data_from_table_direct(file, sheet=0): 
    '''reads curves or other tables from excel or csv'''
    filename, file_extension = os.path.splitext(file)
    try:
        sheets = list(pd.read_excel(file,None,engine='openpyxl').keys())
    except:
        sheets = pd.ExcelFile(file).sheet_names
    if file_extension == '.xlsx' or file_extension == '.xls' or file_extension == '.ods':
        if sheet == 0:
            s_n = 0
        else:
            if sheet in sheets:
                s_n = sheet
            elif str(sheet).upper() in sheets:
                s_n = str(sheet).upper()
            elif str(sheet).lower() in sheets:
                s_n = str(sheet).lower()
            elif str(sheet).capitalize() in sheets:
                s_n = str(sheet).capitalize()
            else:
                s_n = None
        if s_n is not None:
            try:
                data_df = pd.read_excel(file,sheet_name = s_n)
            except:
                data_df = pd.read_excel(file,sheet_name = s_n, engine='openpyxl')
        else:
            data_df = pd.DataFrame()
    if file_extension == '.csv':
        data_df = pd.read_csv(file)
    return data_df
    
    
# Tables (Excel files or gpkg)
def dict_to_excel(
    data_dict,
    save_name,
    folder_save,
    feedback,
    res_prefix = '',
    desired_format = None):
    """
    writes an excel file from a data_dict
    :param dict data_dict
    :param str save_name
    :param str folder_save
    :param QgsProcessingFeedback feedback
    :param str res_prefix: prefix for file name
    :param str desired_format
    """
    if res_prefix != '':
        save_name = res_prefix+'_'+save_name
    if desired_format is not None:
        try:
            save_name = save_name+desired_format
            with pd.ExcelWriter(os.path.join(folder_save, save_name)) as writer:
                for sheet_name, df in data_dict.items():
                    df.to_excel(writer, sheet_name=sheet_name,index = False)
        except:
            raise QgsProcessingException(self.tr('Could not write tables in the desired file format. Please install the package "openpyxl" (or alternatively the package "odf"). Instructions can be found on the in the documentation or on GitHub (https://github.com/Jannik-Schilling/generate_swmm_inp)'))
    else:
        try:
            save_name_xlsx = save_name+'.xlsx'
            with pd.ExcelWriter(os.path.join(folder_save, save_name_xlsx)) as writer:
                for sheet_name, df in data_dict.items():
                    df.to_excel(writer, sheet_name=sheet_name,index = False)
        except:
            try:
                save_name_xls = save_name+'.xls'
                with pd.ExcelWriter(os.path.join(folder_save, save_name_xls)) as writer:
                    for sheet_name, df in data_dict.items():
                        df.to_excel(writer, sheet_name=sheet_name,index = False)
            except:
                try:
                    save_name_ods = save_name+'.ods'
                    with pd.ExcelWriter(os.path.join(folder_save, save_name_ods)) as writer:
                        for sheet_name, df in data_dict.items():
                            df.to_excel(writer, sheet_name=sheet_name,index = False)
                except:
                    raise QgsProcessingException(self.tr('Could not write tables in .xlsx, .xls, or .ods format. Please install the package "openpyxl" (or alternatively the package "odf"). Instructions can be found on the in the documentation or on GitHub (https://github.com/Jannik-Schilling/generate_swmm_inp)'))

def dict_to_gpkg(
    data_dict,
    save_name,
    folder_save,
    feedback,
    res_prefix = ''):
    if res_prefix != '':
        save_name = res_prefix+'_'+save_name

    field_types_dict = {'Double':QVariant.Double,
                        'String':QVariant.String,
                        'Int':QVariant.Int,
                        'Bool': QVariant.Bool}
    
    
    # create layer
    transform_context = QgsProject.instance().transformContext()
    file_path = os.path.join(folder_save,save_name+'.gpkg')
    options = QgsVectorFileWriter.SaveVectorOptions()
    options.fileEnconding = 'utf-8'
    options.driverName = 'GPKG'
    options.EditionCapability = QgsVectorFileWriter.CanAddNewLayer 
    
    first_loop = True
    for sheet_name, df in data_dict.items():
        if first_loop == False:
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        else: 
            first_loop = False
        vector_layer = QgsVectorLayer(
            'NoGeometry',
            sheet_name,
            'memory'
        )
        pr = vector_layer.dataProvider()
        
        layer_fields = df.columns
        print(df.dtypes)
        for col in layer_fields:
            field_type_string = 'String' ##########anpassen
            field_type = field_types_dict[field_type_string]
            pr.addAttributes([QgsField(col, field_type)])
            vector_layer.updateFields()
        df.apply(lambda x: create_feature_from_df(x, pr, 'NoGeometry'), axis =1)
        
        options.layerName = sheet_name
        QgsVectorFileWriter.writeAsVectorFormatV3(
            vector_layer,
            file_path,
            transform_context,
            options
        )

