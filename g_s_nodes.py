# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'

import numpy as np
import pandas as pd
from .g_s_defaults import def_sections_dict, SwmmObject
from .g_s_various_functions import check_columns, get_coords_from_geometry

class SwmmNode(SwmmObject):
    # Attributes      
    SwmmGeomType = 'Point'    
    def __init__(
            self,
            Name,
            Elevation,
            NodeType):
        self.Name = str(Name)
        self.Elevation = float(Elevation)
        self.NodeType = NodeType
        if Name in self.SwmmNodesList:
            raise ValueError('duplicate Name: '+str(Name))
        else:
            self.SwmmNodesList.append(Name)
    

 
# Outfalls           
class SwmmOutfall(SwmmNode):
    # Attributes
    SectionName = 'OUTFALLS'
    QgisLayerFields = {
        'Name':'String',
        'Elevation':'Double',
        'Type':'String',
        'FixedStage':'Double',
        'Curve_TS':'String',
        'FlapGate':'String',
        'RouteTo':'String'
     }
    QgisLayerName = 'SWMM_outfalls'
    QgisLayerStyleFile = 'style_outfalls.qml'
    
    # Functions
    def __init__(self,
        Name,
        Elevation,
        Type,
        FixedStage = np.nan,
        Curve_TS = None,
        FlapGate = 'NO',
        RouteTo = None
    ):
        SwmmNode.__init__(self, Name, Elevation, 'Outfall')
        self.Type = Type
        self.FixedStage = float(FixedStage)
        self.Curve_TS = str(Curve_TS)
        self.FlapGate = FlapGate
        self.RouteTo = RouteTo
    
    def from_inp_line(inp_line):
        """
        creates a SwmmOutfall from a list of attributes
        :param list inp_line
        """
        of_args = dict()
        of_type = inp_line[2]
        if of_type == 'FIXED':
            of_args.update({'FixedStage':inp_line[3]})
        elif of_type == 'TIMESERIES' or of_type == 'TIDAL':
            of_args.update({'Curve_TS':inp_line[3]})
        else: # FREE, NORMAL
            inp_line.insert(3,np.nan)
        of_args.update({'FlapGate':inp_line[4]})
        if len(inp_line) == 6:
            of_args.update({'RouteTo':inp_line[5]})
        return SwmmOutfall(
            inp_line[0], # Name
            inp_line[1], # Elevation
            of_type,
            **of_args            
        )
        
    def to_qgis_row(self):
        """
        creates a pd.Series from a SwmmOutfall
        """
        qgis_row = pd.Series({
            'Name':self.Name,
            'Elevation':self.Elevation,
            'Type':self.Type,
            'FixedStage':self.FixedStage,
            'Curve_TS':self.Curve_TS,
            'FlapGate':self.FlapGate,
            'RouteTo':self.RouteTo
        })
        return qgis_row

# Outfalls
def get_outfalls_from_shapefile(outfalls_raw):
    outfalls_raw.loc[outfalls_raw['Type'] == 'TIDAL', 'Data'] = outfalls_raw.loc[outfalls_raw['Type'] == 'TIDAL','Curve_TS']
    outfalls_raw.loc[outfalls_raw['Type'] == 'TIMESERIES', 'Data'] = outfalls_raw.loc[outfalls_raw['Type'] == 'TIMESERIES','Curve_TS']
    outfalls_raw.loc[outfalls_raw['Type'] == 'FIXED', 'Data'] = outfalls_raw.loc[outfalls_raw['Type'] == 'FIXED','FixedStage']
    outfalls_raw.loc[outfalls_raw['Type'] == 'FREE', 'Data'] = ''
    outfalls_raw.loc[outfalls_raw['Type'] == 'NORMAL', 'Data'] = ''
    outfalls_raw['RouteTo'] = outfalls_raw['RouteTo'].fillna('')
    outfalls_raw['Data'] = outfalls_raw['Data'].fillna('')
    return outfalls_raw





# Storages
st_types_def = {
    'FUNCTIONAL':['Coeff','Exponent','Constant'],
    'TABULAR':['Curve'],
    'PYRAMIDAL':['MajorAxis','MinorAxis','SideSlope'],
    'PARABOLIC':['MajorAxis','MinorAxis','SurfHeight'],
    'CONICAL':['MajorAxis','MinorAxis','SideSlope'],
    'CYLINDRICAL':['MajorAxis','MinorAxis']}
all_st_type_cols = [
    'Curve',
    'Coeff',
    'Exponent',
    'Constant',
    'MajorAxis',
    'MinorAxis',
    'SideSlope',
    'SurfHeight']


def get_storages_from_geodata(storages_raw):
    '''creates a df for storages from raw storage data'''
    storages_layer_name = 'Storages Layer'
    storage_df = storages_raw.copy()
    check_columns(storages_layer_name,
                  ['Type'],
                  storage_df.keys())
    occuring_storage_types = list(set(storages_raw['Type']))
    st_types_needed = list(set([col for s_t in occuring_storage_types for col in st_types_def[s_t]]))
    st_types_not_needed = [col for col in all_st_type_cols if col not in st_types_needed]
    storages_cols = list(def_sections_dict['STORAGE'].keys())
    storages_cols_needed = [col for col in storages_cols if col not in st_types_not_needed]
    check_columns(storages_layer_name,
                  storages_cols_needed,
                  storage_df.keys())
    storage_df['X_Coord'],storage_df['Y_Coord'] = get_coords_from_geometry(storage_df)
    def st_type_adjustment(st_row):
        st_type_i = st_row['Type']
        cols_needed_i = st_types_def[st_type_i]
        if len(cols_needed_i) == 1: #TABULAR
            return st_row[cols_needed_i[0]], '', '' 
        elif len(cols_needed_i) == 2: #CYLINDRICAL
            return st_row[cols_needed_i[0]], st_row[cols_needed_i[1]], 0 
        else:
            return st_row[cols_needed_i[0]], st_row[cols_needed_i[1]], st_row[cols_needed_i[2]]
    storage_df[['Shape1','Shape2','Shape3']] = [st_type_adjustment(storage_df.loc[i]) for i in storage_df.index]
    storage_df['Psi'] = storage_df['Psi'].fillna('')
    storage_df['Ksat'] = storage_df['Ksat'].fillna('')
    storage_df['IMD'] = storage_df['IMD'].fillna('')
    storage_df = storage_df.drop(columns=st_types_needed)
    return storage_df

def get_storages_from_inp(st_raw_line):
    '''adjusts '''
    init_elems = st_raw_line[:5]
    st_type_i = st_raw_line[4]
    st_cols_i = st_types_def[st_type_i]
    st_vals_i = {col:st_raw_line[5+i] for i,col in enumerate(st_cols_i)}
    st_missing = {col_0:np.nan for col_0 in all_st_type_cols if col_0 not in st_vals_i.keys()}
    st_vals_i.update(st_missing)
    type_elems = [st_vals_i[t_c] for t_c in all_st_type_cols]
    # Seepage and Evaporation loss
    if st_type_i == 'TABULAR':
        sur_elems = st_raw_line[6:]
    else:
        sur_elems = st_raw_line[8:]
    if len(sur_elems) == 2:
        sur_elems = sur_elems+[np.nan,np.nan,np.nan]
    # resulting line
    st_line_adjusted = init_elems+type_elems+sur_elems
    return(st_line_adjusted)
    


#inflows
def get_inflows_from_table(inflows_raw,all_nodes):
    '''
    generates a dict for direct inflow and
    dry weather inflow from tables in "inflows_raw"
    '''
    def compose_infl_dict(inflow,i,inf_type):
        if inf_type == 'Direct':
            i_dict = {'Name':i,
               'Constituent':inflow['Constituent'],
               'Time_Series':inflow['Time_Series'],
               'Type':inflow['Type'],
               'Mfactor':inflow['Units_Factor'],
               'Sfactor':inflow['Scale_Factor'],
               'Baseline':inflow['Baseline'],
               'Pattern':inflow['Baseline_Pattern']}
        else:
            i_dict = {'Name':i,
                      'Constituent':inflow['Constituent'],
                      'Baseline':inflow['Average_Value'],
                      'Patterns':' '.join([inflow['Time_Pattern1'],
                                           inflow['Time_Pattern2'],
                                           inflow['Time_Pattern3'],
                                           inflow['Time_Pattern4']])}
        return i_dict
    for inflow_type in ['Direct','Dry_Weather']:
        # check if all columns exits
        inflow_df = inflows_raw[inflow_type]
        if inflow_type == 'Direct':
            inflow_cols_needed = list(def_sections_dict['INFLOWS'])
        if inflow_type == 'Dry_Weather':
            inflow_cols_needed = list(def_sections_dict['DWF'])
        table_name = inflow_type+' table'
        check_columns(table_name,
                      inflow_cols_needed,
                      inflow_df.columns)
        # delete inflows for nodes which do no exist
        inflow_df = inflow_df[inflow_df['Name'] != ";"]
        inflow_df = inflow_df[inflow_df['Name'].isin(all_nodes)]
        inflow_df = inflow_df[pd.notna(inflow_df['Name'])]
        inflow_df = inflow_df.fillna('""')
        if inflow_df.empty: 
            #if no flow of the current inflow_type and existing nodes is given, return empty dicts
            if inflow_type == 'Direct':
                inflow_dict={}
            else:
                dwf_dict={}
        else:
            # prepare a dict with node names and constituents
            a_l = inflow_df['Name'].tolist()
            b_l = inflow_df['Constituent'].tolist()
            inflow_df['temp'] = [str(a)+'    '+str(b) for a,b in zip(a_l, b_l)]
            inflow_df.set_index(keys=['temp'], inplace=True)
            if inflow_type == 'Direct':
                inflow_dict = {i:compose_infl_dict(inflow_df.loc[i,:],i,inflow_type)  for i in inflow_df.index}
            else: 
                dwf_dict = {i:compose_infl_dict(inflow_df.loc[i,:],i,inflow_type)  for i in inflow_df.index}
    return dwf_dict, inflow_dict



# Dividers           
class SwmmDivider(SwmmNode):
    # Attributes
    SectionName = 'DIVIDERS'
    QgisLayerFields = {
        'Name':'String',
        'Elevation':'Double',
        'DivertLink':'String',
        'Type':'String',
        'CutoffFlow':'Double',
        'Curve':'String',
        'WeirMinFlo':'Double',
        'WeirMaxDep':'Double',
        'WeirCoeff':'Double',
        'MaxDepth':'Double',
        'InitDepth':'Double',
        'SurDepth':'Double',
        'Aponded':'Double'}
    QgisLayerName = 'SWMM_dividers'
    QgisLayerStyleFile = 'style_dividers.qml'

    
    # Functions
    def __init__(self,
        Name,
        Elevation,
        DivertLink,
        Type,
        CutoffFlow = np.nan,
        Curve = None,
        WeirMinFlo = np.nan,
        WeirMaxDep = np.nan,
        WeirCoeff = np.nan,
        MaxDepth = np.nan,
        InitDepth = np.nan,
        SurDepth = np.nan,
        Aponded = np.nan
    ):
        SwmmNode.__init__(self, Name, Elevation, 'Divider')
        self.DivertLink = str(DivertLink)
        self.Type = str(Type)
        self.CutoffFlow = float(CutoffFlow)
        self.Curve = str(Curve)
        self.WeirMinFlo = float(WeirMinFlo)
        self.WeirMaxDep = float(WeirMaxDep)
        self.WeirCoeff = float(WeirCoeff)
        self.MaxDepth = float(MaxDepth)
        self.InitDepth = float(InitDepth)
        self.SurDepth = float(SurDepth)
        self.Aponded = float(Aponded)
    
    def from_inp_line(inp_line):
        """
        creates a SwmmDivider from a list of attributes
        :param list of_line
        """
        d_args = dict()
        d_type = inp_line[3]
        if d_type == 'OVERFLOW':
            depth_list = inp_line[4:]
        elif d_type == 'CUTOFF':
            d_args.update({'CutoffFlow':inp_line[4]})
            depth_list = inp_line[5:]
        elif d_type == 'TABULAR':
            d_args.update({'Curve':inp_line[4]})
            depth_list = inp_line[5:]
        else: # WEIR
            d_args.update({
                'WeirMinFlo':inp_line[4],
                'WeirMaxDep':inp_line[5],
                'WeirCoeff':inp_line[6]
            })
            depth_list = inp_line[7:]
        d_args.update({
            'MaxDepth':depth_list[0],
            'InitDepth':depth_list[1],
            'SurDepth':depth_list[2],
            'Aponded':depth_list[3],
        })
        return SwmmDivider(
            inp_line[0], # Name
            inp_line[1], # Elevation
            inp_line[2], # DivertLink
            d_type,
            **d_args            
        )
        
    def to_qgis_row(self):
        """
        creates a pd.Series from a SwmmOutfall
        """
        qgis_row = pd.Series({
            'Name':self.Name,
            'Elevation':self.Elevation,
            'DivertLink':self.DivertLink,
            'Type':self.Type,
            'CutoffFlow':self.CutoffFlow,
            'Curve':self.Curve,
            'WeirMinFlo':self.WeirMinFlo,
            'WeirMaxDep':self.WeirMaxDep,
            'WeirCoeff':self.WeirCoeff,
            'MaxDepth':self.MaxDepth,
            'InitDepth':self.InitDepth,
            'SurDepth':self.SurDepth,
            'Aponded':self.Aponded
        })
        return qgis_row
