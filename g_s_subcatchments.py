# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'


import pandas as pd
import numpy as np
from qgis.core import QgsProcessingException
from .g_s_various_functions import check_columns
from .g_s_defaults import def_qgis_fields_dict, def_sections_dict


def get_subcatchments_from_layer(subcatchments_df, main_infiltration_method):
    """
    reads subcatchment shapefile
    """
    # check if all columns exist
    all_sub_cols = list(def_qgis_fields_dict['SUBCATCHMENTS'].keys())
    sub_layer_name = 'Subcatchments Layer'
    check_columns(
        sub_layer_name,
        all_sub_cols,
        subcatchments_df.keys()
    )

    def rename_for_infiltation(subc_row, main_infiltration_method):
        """
        selects and renames different columns
        according to the columns 'InfMethod'
        """
        infiltr_method = subc_row['InfMethod']
        if pd.isna(infiltr_method):
            # take main infiltration method, if not given for subcatchment
            infiltr_method = main_infiltration_method
        if infiltr_method in ['GREEN_AMPT', 'MODIFIED_GREEN_AMPT']:
            subc_row = subc_row.rename({
                'SuctHead': 'Param1',
                'Conductiv': 'Param2',
                'InitDef': 'Param3'
            })
            subc_row['Param4'] = ''
            subc_row['Param5'] = ''
        if infiltr_method in ['HORTON', 'MODIFIED_HORTON']:
            subc_row = subc_row.rename({
                'MaxRate': 'Param1',
                'MinRate': 'Param2',
                'Decay': 'Param3',
                'DryTime': 'Param4',
                'MaxInf': 'Param5'
            })
        if infiltr_method == 'CURVE_NUMBER':
            subc_row = subc_row.rename({
                'CurveNum': 'Param1',
                'Conductiv': 'Param2',
                'DryTime': 'Param3'
            })
            subc_row['Param4'] = ''
            subc_row['Param5'] = ''
        if infiltr_method is None:
            subc_row['Param1'] = ''
            subc_row['Param2'] = ''
            subc_row['Param3'] = ''
            subc_row['Param4'] = ''
            subc_row['Param5'] = ''
        return subc_row
    subcatchments_df = subcatchments_df.apply(
        rename_for_infiltation,
        axis=1,
        args=(main_infiltration_method, )
    )
    subcatchments_df['SnowPack'] = subcatchments_df['SnowPack'].fillna('')
    subcatchments_df['PctRouted'] = subcatchments_df['PctRouted'].fillna(100)
    subcatchments_df = subcatchments_df.reset_index(drop=True)
    # select columns
    infiltration_df = subcatchments_df[def_sections_dict['INFILTRATION']]
    subareas_df = subcatchments_df[def_sections_dict['SUBAREAS']]
    subcatchments_df = subcatchments_df[def_sections_dict['SUBCATCHMENTS']]
    return subcatchments_df, subareas_df, infiltration_df


def create_subcatchm_attributes_from_inp_df(
    all_subcatchments,
    all_subareas,
    all_infiltr,
    main_infiltration_method
):
    """
    creates pd.Dataframes from lists of subcatchment attributes (from an inp file)
    """
    InfiltrDtypes = [
        'InfMethod',
        'SuctHead',
        'Conductiv',
        'InitDef',
        'MaxRate',
        'MinRate',
        'Decay',
        'DryTime',
        'MaxInf',
        'CurveNum'
    ]

    def create_infiltr_df(infiltr_row, main_infilt_method):
        if pd.isna(infiltr_row['InfMethod']):
            infiltr_row['InfMethod'] = main_infilt_method
        if infiltr_row['InfMethod'] in ['GREEN_AMPT', 'MODIFIED_GREEN_AMPT']:
            infiltr_row = infiltr_row.rename({
                'Param1': 'SuctHead',
                'Param2': 'Conductiv',
                'Param3': 'InitDef'
            })
            infiltr_row = infiltr_row.drop(['Param4', 'Param5'])
            cols_not_in_infilt = [k for k in InfiltrDtypes if k not in infiltr_row.index]  # missing columns
            for c in cols_not_in_infilt:
                infiltr_row[c] = np.nan
        if infiltr_row['InfMethod'] in ['HORTON', 'MODIFIED_HORTON']:
            infiltr_row = infiltr_row.rename({
                'Param1': 'MaxRate',
                'Param2': 'MinRate',
                'Param3': 'Decay',
                'Param4': 'DryTime',
                'Param5': 'MaxInf'
            })
            cols_not_in_infilt = [k for k in InfiltrDtypes if k not in infiltr_row.index]  # missing columns
            for c in cols_not_in_infilt:
                infiltr_row[c] = np.nan
        if infiltr_row['InfMethod'] == 'CURVE_NUMBER':
            infiltr_row = infiltr_row.rename({
                'Param1': 'CurveNum',
                'Param2': 'Conductiv',
                'Param3': 'DryTime'
            })
            infiltr_row = infiltr_row.drop(['Param4', 'Param5'])
            cols_not_in_infilt = [k for k in InfiltrDtypes if k not in infiltr_row.index]  # missing columns
            for c in cols_not_in_infilt:
                infiltr_row[c] = np.nan
        return infiltr_row
    all_infiltr = all_infiltr.apply(lambda x: create_infiltr_df(x, main_infiltration_method), axis=1)
    all_infiltr = all_infiltr[['Name']+InfiltrDtypes]
    all_subcatchments = all_subcatchments.join(all_subareas.set_index('Name'), on='Name')
    all_subcatchments = all_subcatchments.join(all_infiltr.set_index('Name'), on='Name')
    return all_subcatchments


# for raingages
def get_raingages(
    rg_features_df,
    feedback,
    rg_ts_dict=None,
    rg_pos_default=None
):
    """
    generates a raingages dict for the input file from timeseries dict
    :param list rg_ts_list
    :param QgsProcessingFeedback feedback
    """
    rg_dict = {}
    temp_rg_ts = {}
    if rg_ts_dict is not None:
        for v in rg_ts_dict.values():
            v['TimeSeries'] = v['TimeSeries'].reset_index(drop=True)
            rg_i = SwmmRainGage.from_ts(v, feedback)
            temp_rg_ts[v['Description']] = rg_i.to_inp_str()
    return (rg_dict)


# new...
class SwmmRainGage:
    """Rain gage class for SWMM models"""
    def __init__(
        self,
        Name,
        Format,
        Interval,
        SCF,
        Source,
        Position=None
    ):
        self.Name = str(Name)
        self.Format = str(Format)
        self.Interval = str(Interval)
        self.SCF = SCF
        self.Source = Source
        self.Position = Position

    QgisLayerFields = {
        'Name': 'String',
        'Format': 'String',
        'Interval': 'String',
        'SCF': 'Double',
        'DataSource': 'String',
        'SeriesName': 'String',
        'FileName': 'String',
        'StationID': 'String',
        'RainUnits': 'String'
    }

    def from_qgis_row(rg_row):
        if rg_row['DataSource'] == 'TIMESERIES':
            rg_source = {
                'DataSource': 'TIMESERIES',
                'SeriesName': rg_row['SeriesName']
            }
        else:  # FILE
            rg_source = {
                'DataSource': 'FILE',
                'FileName': rg_row['FileName'],
                'StationID': rg_row['StationID'],
                'RainUnits': rg_row['RainUnits']
            }
        return SwmmRainGage(
            rg_row['Name'],
            rg_row['Format'],
            rg_row['Interval'],
            rg_row['SCF'],
            rg_source
        )

    def from_inp_line(rg_line):
        if rg_line[4] == 'TIMESERIES':
            rg_source = {
                'DataSource': 'TIMESERIES',
                'SeriesName': rg_line[5]
            }
        else:  # FILE
            rg_source = {
                'DataSource': 'FILE',
                'FileName': rg_line[5],
                'StationID': rg_line[6],
                'RainUnits': rg_line[7]
            }
        interval_split = str(rg_line[2]).split(':')  # Interval splitted in HH:mm
        if len(interval_split) == 1:
            interval_split = interval_split + ['00']  # if only hours
        if len(interval_split[0]) == 1:
            interval_split[0] = '0' + interval_split[0]  # if one digit hour
        interval = interval_split[0] + ':' + interval_split[1]
        return SwmmRainGage(
            rg_line[0],  # Name
            rg_line[1],  # Format
            interval,
            rg_line[3],  # SCF
            rg_source
        )

    def to_qgis_row(self):
        '''prepares a pandas series for QGIS features'''
        rg_row = pd.Series({
            'Name': self.Name,
            'Format': self.Format,
            'Interval': self.Interval,
            'SCF': self.SCF
        })
        if self.Source['DataSource'] == 'TIMESERIES':
            rg_row['DataSource'] = 'TIMESERIES'
            rg_row['SeriesName'] = str(self.Source['SeriesName'])
            rg_row['FileName'] = np.nan
            rg_row['StationID'] = np.nan
            rg_row['RainUnits'] = np.nan
        if self.Source['DataSource'] == 'FILE':
            rg_row['DataSource'] = 'FILE'
            rg_row['SeriesName'] = np.nan
            rg_row['FileName'] = str(self.Source['FileName'])
            rg_row['StationID'] = str(self.Source['StationID'])
            rg_row['RainUnits'] = str(self.Source['RainUnits'])
        return rg_row

    def to_inp_str(self):
        """writes a string for the input file"""
        if self.Source['DataSource'] == 'TIMESERIES':
            source_string = (
                str(self.Source['DataSource']) + ' ' +
                str(self.Source['SeriesName'])
            )
        if self.Source['DataSource'] == 'FILE':
            source_string = (
                str(self.Source['DataSource']) + ' ' +
                str(self.Source['FileName']) + ' ' +
                str(self.Source['StationID']) + ' ' +
                str(self.Source['RainUnits'])
            )
        inp_str = (
            self.Name + '    ' +
            self.Format + '    ' +
            str(self.Interval) + '    ' +
            str(self.SCF) + '    ' +
            source_string
        )
        return inp_str

        # deprecated:
    def from_ts(rg_ts, feedback):
        """creates a rain gage from timeseries dict"""
        rg_source = {
            'DataSource': 'TIMESERIES',
            'SeriesName': rg_ts['Name']}
        try:
            timediff = datetime.strptime(rg_i['TimeSeries']['Time'][1], '%H:%M')-datetime.strptime(rg_i['TimeSeries']['Time'][0], '%H:%M')
            rg_interval = str(timediff)[:-3]
        except:
            rg_interval = ('5')  # set to ten minutes
            feedback.setProgressText(
                'Time interval for rain gage "'
                + rg_ts['Description']
                + '"could not be determined and was set by default '
                + 'to 5 Minutes. Please check in SWMM.'
            )
        return SwmmRainGage(
            rg_ts['Description'],
            rg_ts['Format'],
            rg_interval,
            1,
            rg_source,
        )
