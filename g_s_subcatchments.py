# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenerateSwmmInp
                                 A QGIS plugin
 This plugin generates SWMM Input files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-09
        copyright            : (C) 2022 by Jannik Schilling
        email                : jannik.schilling@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2022-04-28'
__copyright__ = '(C) 2022 by Jannik Schilling'


import pandas as pd
import numpy as np
from qgis.core import QgsProcessingException
from .g_s_various_functions import check_columns
from .g_s_defaults import def_sections_dict, def_infiltr_dtypes

#subcatchments_df = raw_data_dict['subcatchments_raw']
def get_subcatchments_from_shapefile(subcatchments_df, main_infiltration_method):
    """
    reads subcatchment shapefile
    """
    # check if all columns exist
    subc_cols = list(def_sections_dict['SUBCATCHMENTS'].keys())
    suba_cols = list(def_sections_dict['SUBAREAS'].keys())
    all_sub_cols = subc_cols+suba_cols+['InfMethod']
    sub_layer_name = 'Subcatchments Layer'
    check_columns(sub_layer_name,
                  all_sub_cols,
                  subcatchments_df.keys())

    def rename_for_infiltation(subc_row, main_infiltration_method):
        """selects and renames different columns according to the columns 'InfMethod'"""
        infiltr_method = subc_row['InfMethod']
        if pd.isna(infiltr_method):
            # take main infiltration method, if not given for subcatchment
            infiltr_method = main_infiltration_method
        if infiltr_method in ['GREEN_AMPT','MODIFIED_GREEN_AMPT']:
            subc_row = subc_row.rename({'SuctHead':'Param1',
                                        'Conductiv':'Param2',
                                        'InitDef':'Param3'})
            subc_row['Param4'] = ''
            subc_row['Param5'] = ''
        if infiltr_method in ['HORTON','MODIFIED_HORTON']:
            subc_row = subc_row.rename({'MaxRate':'Param1', 
                                        'MinRate':'Param2',
                                        'Decay':'Param3',  
                                        'DryTime':'Param4', 
                                        'MaxInf':'Param5'})
        if infiltr_method == 'CURVE_NUMBER':
            subc_row = subc_row.rename({'CurveNum':'Param1',
                                        'Conductiv':'Param2', 
                                        'DryTime':'Param3'})
            subc_row['Param4'] = ''
            subc_row['Param5'] = ''
        if infiltr_method is None:
            subc_row['Param1'] = ''
            subc_row['Param2'] = ''
            subc_row['Param3'] = ''
            subc_row['Param4'] = ''
            subc_row['Param5'] = ''
        return subc_row
    subcatchments_df = subcatchments_df.apply(rename_for_infiltation, 
                                              axis=1, 
                                              args=(main_infiltration_method,))
    subcatchments_df['SnowPack'] = subcatchments_df['SnowPack'].fillna('')
    subcatchments_df['PctRouted'] = subcatchments_df['PctRouted'].fillna(100)
    subcatchments_df = subcatchments_df.reset_index(drop=True)
    return(subcatchments_df)

def create_subcatchm_attributes_from_inp_df(all_subcatchments, all_subareas, all_infiltr, main_infiltration_method):
    """creates pd.Dataframes from lists of subcatchment attributes (from an inp file)"""
    def_infiltr_dtypes = {'InfMethod':'String',
                      'SuctHead':'Double',
                      'Conductiv':'Double',
                      'InitDef':'Double',
                      'MaxRate':'Double',
                      'MinRate':'Double',
                      'Decay':'Double',
                      'DryTime':'Double',
                      'MaxInf':'Double',
                      'CurveNum':'Double'}
    def create_infiltr_df(infiltr_row, main_infilt_method):
        if pd.isna(infiltr_row['InfMethod']):
            infiltr_row['InfMethod'] = main_infilt_method
        if infiltr_row['InfMethod'] in ['GREEN_AMPT','MODIFIED_GREEN_AMPT']:
            infiltr_row = infiltr_row.rename({'Param1':'SuctHead',
                               'Param2':'Conductiv',
                               'Param3':'InitDef'})
            infiltr_row = infiltr_row.drop(['Param4','Param5'])
            cols_not_in_infilt =[k for k in def_infiltr_dtypes.keys() if k not in infiltr_row.index]# missing columns
            for c in cols_not_in_infilt:
                infiltr_row[c] = np.nan
        if infiltr_row['InfMethod'] in ['HORTON','MODIFIED_HORTON']:
            infiltr_row = infiltr_row.rename({'Param1':'MaxRate',
                                   'Param2':'MinRate',
                                   'Param3':'Decay',
                                   'Param4':'DryTime',
                                   'Param5':'MaxInf'})
            cols_not_in_infilt =[k for k in def_infiltr_dtypes.keys() if k not in infiltr_row.index]# missing columns
            for c in cols_not_in_infilt:
                infiltr_row[c] = np.nan
        if infiltr_row['InfMethod'] == 'CURVE_NUMBER':
            infiltr_row = infiltr_row.rename({'Param1':'CurveNum',
                               'Param2':'Conductiv',
                               'Param3':'DryTime'})
            infiltr_row = infiltr_row.drop(['Param4','Param5'])
            cols_not_in_infilt =[k for k in def_infiltr_dtypes.keys() if k not in infiltr_row.index]# missing columns
            for c in cols_not_in_infilt:
                infiltr_row[c] = np.nan
        return infiltr_row
    all_infiltr = all_infiltr.apply(lambda x: create_infiltr_df(x, main_infiltration_method), axis =1)
    all_infiltr = all_infiltr[['Name']+list(def_infiltr_dtypes.keys())]
    all_infiltr = all_infiltr.dropna(how='all', axis=1) # if all subcatchments have the same infiltration method
    def_infiltr_dtypes = {k:v for k,v in def_infiltr_dtypes.items() if k in all_infiltr.columns} 
    all_subcatchments = all_subcatchments.join(all_subareas.set_index('Name'), on = 'Name')
    all_subcatchments = all_subcatchments.join(all_infiltr.set_index('Name'), on = 'Name')
    return all_subcatchments, def_infiltr_dtypes

subc_field_vals = {
    'RouteTo':{
        'OUTLET':'OUTLET',
        'PERVIOUS':'PERVIOUS',
        'IMPERVIOUS':'IMPERVIOUS'},
    'InfMethod':{
        'HORTON':'HORTON',
        'MODIFIED_HORTON':'MODIFIED_HORTON',
        'GREEN_AMPT':'GREEN_AMPT',
        'MODIFIED_GREEN_AMPT':'MODIFIED_GREEN_AMPT',
        'CURVE_NUMBER':'CURVE_NUMBER'}}




##for raingages

def rg_position_default(polyg_dict):
    """sets the default position of a rain gauge based on all subcatchment polygons"""
    all_yx = pd.concat([v for k,v in polyg_dict.items()])
    x_mean = np.mean(all_yx['x'])+10
    y_mean = np.mean(all_yx['y'])+10
    return x_mean, y_mean

def get_raingages_from_timeseries(rg_ts_dict, rg_pos_default, feedback):
    """
    generates a raingages dict for the input file from timeseries dict
    :param list rg_ts_list
    :param QgsProcessingFeedback feedback
    """
    rg_dict= {}
    for v in rg_ts_dict.values():
        v['TimeSeries'] = v['TimeSeries'].reset_index(drop=True)
        rg_i = SwmmRainGage.from_ts(v, feedback)
        rg_dict[v['Description']] = rg_i.to_inp_str()
    return (rg_dict)
    

class SwmmRainGage:
    """Rain gage class for SWMM models"""
    def __init__(self,
            Name,
            Format,
            Source,
            Interval = None,
            SCF = 1,
            Position = None):
        self.Name = str(Name)
        self.Format = str(Format)
        self.Interval = Interval
        self.Source = Source
        self.Position = Position
        self.SCF = 1
        
    def from_ts(rg_ts, feedback):
        """creates a rain gage from timeseries dict"""
        rg_source = {
            'Type':'TIMESERIES',
            'TS_Name': rg_ts['Name']}
        try:
            timediff = datetime.strptime(rg_i['TimeSeries']['Time'][1],'%H:%M')-datetime.strptime(rg_i['TimeSeries']['Time'][0],'%H:%M')
            rg_interval = str(timediff)[:-3]
        except:
            rg_interval = ('5') #set to ten minutes
            feedback.setProgressText('Time interval for rain gage "'
                +rg_ts['Description']+
                '"could not be determined and was set by default to 5 Minutes. Please check in SWMM.')
        return SwmmRainGage(
            rg_ts['Description'],
            rg_ts['Format'],
            rg_source,
            rg_interval)
            
    def to_inp_str(self):
        """writes a string for the input file"""
        if self.Source['Type'] == 'TIMESERIES':
            source_string = (str(self.Source['Type'])+' '+
                str(self.Source['TS_Name']))
        if self.Source['Type'] == 'FILE':
            source_string = (str(self.Source['Type'])+' '+
                str(self.Source['TS_Name'])+' '+
                str(self.Source['Station'])+' '+
                str(self.Source['RainUnit']))
        inp_str = (self.Name+'    '+
            self.Format+'    '+
            str(self.Interval)+'    '+
            str(self.SCF)+'    '+
            source_string)
        return inp_str